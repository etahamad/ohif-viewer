{"version":3,"file":"147.bundle.a59a980d3dd3a8c52b87.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/ViewportImageScrollbar.tsx","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/utils.ts","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/CustomizableViewportOverlay.tsx","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/ViewportOrientationMarkers.tsx","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/ViewportImageSliceLoadingIndicator.tsx","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/CornerstoneOverlays.tsx","webpack:///../../../extensions/cornerstone/src/components/CinePlayer/CinePlayer.tsx","webpack:///../../../extensions/cornerstone/src/components/CinePlayer/index.ts","webpack:///../../../extensions/cornerstone/src/components/OHIFViewportActionCorners.tsx","webpack:///../../../extensions/cornerstone/src/utils/ActiveViewportBehavior.tsx","webpack:///../../../extensions/cornerstone/src/Viewport/OHIFCornerstoneViewport.tsx","webpack:///../../../extensions/cornerstone/src/utils/presentations/getViewportPresentations.ts"],"sourcesContent":["import React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { Enums, VolumeViewport3D, utilities as csUtils } from '@cornerstonejs/core';\nimport { ImageScrollbar } from '@ohif/ui-next';\n\nfunction CornerstoneImageScrollbar({\n  viewportData,\n  viewportId,\n  element,\n  imageSliceData,\n  setImageSliceData,\n  scrollbarHeight,\n  servicesManager,\n}: withAppTypes<{\n  element: HTMLElement;\n}>) {\n  const { cineService, cornerstoneViewportService } = servicesManager.services;\n\n  const onImageScrollbarChange = (imageIndex, viewportId) => {\n    const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n    const { isCineEnabled } = cineService.getState();\n\n    if (isCineEnabled) {\n      // on image scrollbar change, stop the CINE if it is playing\n      cineService.stopClip(element, { viewportId });\n      cineService.setCine({ id: viewportId, isPlaying: false });\n    }\n\n    csUtils.jumpToSlice(viewport.element, {\n      imageIndex,\n      debounceLoading: true,\n    });\n  };\n\n  useEffect(() => {\n    if (!viewportData) {\n      return;\n    }\n\n    const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n    if (!viewport || viewport instanceof VolumeViewport3D) {\n      return;\n    }\n\n    try {\n      const imageIndex = viewport.getCurrentImageIdIndex();\n      const numberOfSlices = viewport.getNumberOfSlices();\n\n      setImageSliceData({\n        imageIndex: imageIndex,\n        numberOfSlices,\n      });\n    } catch (error) {\n      console.warn(error);\n    }\n  }, [viewportId, viewportData]);\n\n  useEffect(() => {\n    if (!viewportData) {\n      return;\n    }\n    const { viewportType } = viewportData;\n    const eventId =\n      (viewportType === Enums.ViewportType.STACK && Enums.Events.STACK_NEW_IMAGE) ||\n      (viewportType === Enums.ViewportType.ORTHOGRAPHIC && Enums.Events.VOLUME_NEW_IMAGE) ||\n      Enums.Events.IMAGE_RENDERED;\n\n    const updateIndex = event => {\n      const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n      if (!viewport || viewport instanceof VolumeViewport3D) {\n        return;\n      }\n      const { imageIndex, newImageIdIndex = imageIndex, imageIdIndex } = event.detail;\n      const numberOfSlices = viewport.getNumberOfSlices();\n      // find the index of imageId in the imageIds\n      setImageSliceData({\n        imageIndex: newImageIdIndex ?? imageIdIndex,\n        numberOfSlices,\n      });\n    };\n\n    element.addEventListener(eventId, updateIndex);\n\n    return () => {\n      element.removeEventListener(eventId, updateIndex);\n    };\n  }, [viewportData, element]);\n\n  return (\n    <ImageScrollbar\n      onChange={evt => onImageScrollbarChange(evt, viewportId)}\n      max={imageSliceData.numberOfSlices ? imageSliceData.numberOfSlices - 1 : 0}\n      height={scrollbarHeight}\n      value={imageSliceData.imageIndex || 0}\n    />\n  );\n}\n\nCornerstoneImageScrollbar.propTypes = {\n  viewportData: PropTypes.object,\n  viewportId: PropTypes.string.isRequired,\n  element: PropTypes.instanceOf(Element),\n  scrollbarHeight: PropTypes.string,\n  imageSliceData: PropTypes.object.isRequired,\n  setImageSliceData: PropTypes.func.isRequired,\n  servicesManager: PropTypes.object.isRequired,\n};\n\nexport default CornerstoneImageScrollbar;\n","import moment from 'moment';\nimport { metaData } from '@cornerstonejs/core';\n\n/**\n * Checks if value is valid.\n *\n * @param {number} value\n * @returns {boolean} is valid.\n */\nexport function isValidNumber(value) {\n  return typeof value === 'number' && !isNaN(value);\n}\n\n/**\n * Formats number precision.\n *\n * @param {number} number\n * @param {number} precision\n * @returns {number} formatted number.\n */\nexport function formatNumberPrecision(number, precision = 0) {\n  if (number !== null) {\n    return parseFloat(number).toFixed(precision);\n  }\n}\n\n/**\n * Formats DICOM date.\n *\n * @param {string} date\n * @param {string} strFormat\n * @returns {string} formatted date.\n */\nexport function formatDICOMDate(date, strFormat = 'MMM D, YYYY') {\n  return moment(date, 'YYYYMMDD').format(strFormat);\n}\n\n/**\n *    DICOM Time is stored as HHmmss.SSS, where:\n *      HH 24 hour time:\n *        m mm        0..59   Minutes\n *        s ss        0..59   Seconds\n *        S SS SSS    0..999  Fractional seconds\n *\n *        Goal: '24:12:12'\n *\n * @param {*} time\n * @param {string} strFormat\n * @returns {string} formatted name.\n */\nexport function formatDICOMTime(time, strFormat = 'HH:mm:ss') {\n  return moment(time, 'HH:mm:ss').format(strFormat);\n}\n\n/**\n * Gets compression type\n *\n * @param {number} imageId\n * @returns {string} compression type.\n */\nexport function getCompression(imageId) {\n  const generalImageModule = metaData.get('generalImageModule', imageId) || {};\n  const { lossyImageCompression, lossyImageCompressionRatio, lossyImageCompressionMethod } =\n    generalImageModule;\n\n  if (lossyImageCompression === '01' && lossyImageCompressionRatio !== '') {\n    const compressionMethod = lossyImageCompressionMethod || 'Lossy: ';\n    const compressionRatio = formatNumberPrecision(lossyImageCompressionRatio, 2);\n    return compressionMethod + compressionRatio + ' : 1';\n  }\n\n  return 'Lossless / Uncompressed';\n}\n","import React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport { vec3 } from 'gl-matrix';\nimport PropTypes from 'prop-types';\nimport { metaData, Enums, utilities, eventTarget } from '@cornerstonejs/core';\nimport { Enums as csToolsEnums, UltrasoundPleuraBLineTool } from '@cornerstonejs/tools';\nimport type { ImageSliceData } from '@cornerstonejs/core/types';\nimport { ViewportOverlay } from '@ohif/ui-next';\nimport type { InstanceMetadata } from '@ohif/core/src/types';\nimport { formatDICOMDate, formatDICOMTime, formatNumberPrecision } from './utils';\nimport { utils } from '@ohif/core';\nimport { StackViewportData, VolumeViewportData } from '../../types/CornerstoneCacheService';\n\nimport './CustomizableViewportOverlay.css';\nimport { useViewportRendering } from '../../hooks';\n\nconst EPSILON = 1e-4;\nconst { formatPN } = utils;\n\ntype ViewportData = StackViewportData | VolumeViewportData;\n\ninterface OverlayItemProps {\n  element: HTMLElement;\n  viewportData: ViewportData;\n  imageSliceData: ImageSliceData;\n  servicesManager: AppTypes.ServicesManager;\n  viewportId: string;\n  instance: InstanceMetadata;\n  customization: any;\n  formatters: {\n    formatPN: (val) => string;\n    formatDate: (val) => string;\n    formatTime: (val) => string;\n    formatNumberPrecision: (val, number) => string;\n  };\n\n  // calculated values\n  voi: {\n    windowWidth: number;\n    windowCenter: number;\n  };\n  instanceNumber?: number;\n  scale?: number;\n}\n\nconst OverlayItemComponents = {\n  'ohif.overlayItem': OverlayItem,\n  'ohif.overlayItem.windowLevel': VOIOverlayItem,\n  'ohif.overlayItem.zoomLevel': ZoomOverlayItem,\n  'ohif.overlayItem.instanceNumber': InstanceNumberOverlayItem,\n};\n\n/**\n * Customizable Viewport Overlay\n */\nfunction CustomizableViewportOverlay({\n  element,\n  viewportData,\n  imageSliceData,\n  viewportId,\n  servicesManager,\n}: {\n  element: HTMLElement;\n  viewportData: ViewportData;\n  imageSliceData: ImageSliceData;\n  viewportId: string;\n  servicesManager: AppTypes.ServicesManager;\n}) {\n  const { cornerstoneViewportService, customizationService, toolGroupService, displaySetService } =\n    servicesManager.services;\n  const [voi, setVOI] = useState({ windowCenter: null, windowWidth: null });\n  const [scale, setScale] = useState(1);\n  const [annotationState, setAnnotationState] = useState(0);\n  const { isViewportBackgroundLight: isLight } = useViewportRendering(viewportId);\n  const { imageIndex } = imageSliceData;\n\n  // Historical usage defined the overlays as separate items due to lack of\n  // append functionality.  This code enables the historical usage, but\n  // the recommended functionality is to append to the default values in\n  // cornerstoneOverlay rather than defining individual items.\n  const topLeftCustomization = customizationService.getCustomization('viewportOverlay.topLeft');\n  const topRightCustomization = customizationService.getCustomization('viewportOverlay.topRight');\n  const bottomLeftCustomization = customizationService.getCustomization(\n    'viewportOverlay.bottomLeft'\n  );\n  const bottomRightCustomization = customizationService.getCustomization(\n    'viewportOverlay.bottomRight'\n  );\n\n  const instanceNumber = useMemo(\n    () =>\n      viewportData\n        ? getInstanceNumber(viewportData, viewportId, imageIndex, cornerstoneViewportService)\n        : null,\n    [viewportData, viewportId, imageIndex, cornerstoneViewportService]\n  );\n\n  const displaySetProps = useMemo(() => {\n    const displaySets = getDisplaySets(viewportData, displaySetService);\n    if (!displaySets) {\n      return null;\n    }\n    const [displaySet] = displaySets;\n    const { instances, instance: referenceInstance } = displaySet;\n    return {\n      displaySets,\n      displaySet,\n      instance: instances?.[imageIndex],\n      instances,\n      referenceInstance,\n    };\n  }, [viewportData, viewportId, instanceNumber, cornerstoneViewportService]);\n\n  /**\n   * Updating the VOI when the viewport changes its voi\n   */\n  useEffect(() => {\n    const updateVOI = eventDetail => {\n      const { range } = eventDetail.detail;\n\n      if (!range) {\n        return;\n      }\n\n      const { lower, upper } = range;\n      const { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(lower, upper);\n\n      setVOI({ windowCenter, windowWidth });\n    };\n\n    element.addEventListener(Enums.Events.VOI_MODIFIED, updateVOI);\n\n    return () => {\n      element.removeEventListener(Enums.Events.VOI_MODIFIED, updateVOI);\n    };\n  }, [viewportId, viewportData, voi, element]);\n\n  const annotationModified = useCallback(evt => {\n    if (evt.detail.annotation.metadata.toolName === UltrasoundPleuraBLineTool.toolName) {\n      // Update the annotation state to trigger a re-render\n      setAnnotationState(prevState => prevState + 1);\n    }\n  }, []);\n\n  useEffect(() => {\n    eventTarget.addEventListener(csToolsEnums.Events.ANNOTATION_MODIFIED, annotationModified);\n\n    return () => {\n      eventTarget.removeEventListener(csToolsEnums.Events.ANNOTATION_MODIFIED, annotationModified);\n    };\n  }, [annotationModified]);\n  /**\n   * Updating the scale when the viewport changes its zoom\n   */\n  useEffect(() => {\n    const updateScale = eventDetail => {\n      const { previousCamera, camera } = eventDetail.detail;\n\n      if (\n        previousCamera.parallelScale !== camera.parallelScale ||\n        previousCamera.scale !== camera.scale\n      ) {\n        const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n        if (!viewport) {\n          return;\n        }\n\n        const scale = viewport.getZoom();\n\n        setScale(scale);\n      }\n    };\n\n    element.addEventListener(Enums.Events.CAMERA_MODIFIED, updateScale);\n\n    return () => {\n      element.removeEventListener(Enums.Events.CAMERA_MODIFIED, updateScale);\n    };\n  }, [viewportId, viewportData, cornerstoneViewportService, element]);\n\n  const _renderOverlayItem = useCallback(\n    (item, props) => {\n      const overlayItemProps = {\n        ...props,\n        element,\n        viewportData,\n        imageSliceData,\n        viewportId,\n        servicesManager,\n        customization: item,\n        isLight,\n        formatters: {\n          formatPN,\n          formatDate: formatDICOMDate,\n          formatTime: formatDICOMTime,\n          formatNumberPrecision,\n        },\n      };\n\n      if (!item) {\n        return null;\n      }\n\n      const { inheritsFrom } = item;\n      const OverlayItemComponent = OverlayItemComponents[inheritsFrom];\n\n      if (OverlayItemComponent) {\n        return <OverlayItemComponent {...overlayItemProps} />;\n      } else {\n        const renderItem = customizationService.transform(item);\n\n        if (typeof renderItem.contentF === 'function') {\n          return renderItem.contentF(overlayItemProps);\n        }\n      }\n    },\n    [\n      element,\n      viewportData,\n      imageSliceData,\n      viewportId,\n      servicesManager,\n      customizationService,\n      displaySetProps,\n      voi,\n      scale,\n      instanceNumber,\n      annotationState,\n    ]\n  );\n\n  const getContent = useCallback(\n    (customization, keyPrefix) => {\n      const props = {\n        ...displaySetProps,\n        formatters: { formatDate: formatDICOMDate },\n        voi,\n        scale,\n        instanceNumber,\n        viewportId,\n        toolGroupService,\n        isLight,\n      };\n\n      return (\n        <>\n          {customization.map((item, index) => (\n            <div key={`${keyPrefix}_${index}`}>\n              {((!item?.condition || item.condition(props)) && _renderOverlayItem(item, props)) ||\n                null}\n            </div>\n          ))}\n        </>\n      );\n    },\n    [_renderOverlayItem]\n  );\n\n  return (\n    <ViewportOverlay\n      topLeft={getContent(topLeftCustomization, 'topLeftOverlayItem')}\n      topRight={getContent(topRightCustomization, 'topRightOverlayItem')}\n      bottomLeft={getContent(bottomLeftCustomization, 'bottomLeftOverlayItem')}\n      bottomRight={getContent(bottomRightCustomization, 'bottomRightOverlayItem')}\n      color={isLight ? 'text-neutral-dark' : 'text-neutral-light'}\n      shadowClass={isLight ? 'shadow-light' : 'shadow-dark'}\n    />\n  );\n}\n\n/**\n * Gets an array of display sets for the given viewport, based on the viewport data.\n * Returns null if none found.\n */\nfunction getDisplaySets(viewportData, displaySetService) {\n  if (!viewportData?.data?.length) {\n    return null;\n  }\n  const displaySets = viewportData.data\n    .map(datum => displaySetService.getDisplaySetByUID(datum.displaySetInstanceUID))\n    .filter(it => !!it);\n  if (!displaySets.length) {\n    return null;\n  }\n  return displaySets;\n}\n\nconst getInstanceNumber = (viewportData, viewportId, imageIndex, cornerstoneViewportService) => {\n  let instanceNumber;\n\n  switch (viewportData.viewportType) {\n    case Enums.ViewportType.STACK:\n      instanceNumber = _getInstanceNumberFromStack(viewportData, imageIndex);\n      break;\n    case Enums.ViewportType.ORTHOGRAPHIC:\n      instanceNumber = _getInstanceNumberFromVolume(\n        viewportData,\n        viewportId,\n        cornerstoneViewportService,\n        imageIndex\n      );\n      break;\n  }\n\n  return instanceNumber ?? null;\n};\n\nfunction _getInstanceNumberFromStack(viewportData, imageIndex) {\n  const imageIds = viewportData.data[0].imageIds;\n  const imageId = imageIds[imageIndex];\n\n  if (!imageId) {\n    return;\n  }\n\n  const generalImageModule = metaData.get('generalImageModule', imageId) || {};\n  const { instanceNumber } = generalImageModule;\n\n  const stackSize = imageIds.length;\n\n  if (stackSize <= 1) {\n    return;\n  }\n\n  return parseInt(instanceNumber);\n}\n\n// Since volume viewports can be in any view direction, they can render\n// a reconstructed image which don't have imageIds; therefore, no instance and instanceNumber\n// Here we check if viewport is in the acquisition direction and if so, we get the instanceNumber\nfunction _getInstanceNumberFromVolume(\n  viewportData,\n  viewportId,\n  cornerstoneViewportService,\n  imageIndex\n) {\n  const volumes = viewportData.data;\n\n  if (!volumes) {\n    return;\n  }\n\n  // Todo: support fusion of acquisition plane which has instanceNumber\n  const { volume } = volumes[0];\n\n  if (!volume) {\n    return;\n  }\n\n  const { direction, imageIds } = volume;\n\n  const cornerstoneViewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n  if (!cornerstoneViewport) {\n    return;\n  }\n\n  const camera = cornerstoneViewport.getCamera();\n  const { viewPlaneNormal } = camera;\n  // checking if camera is looking at the acquisition plane (defined by the direction on the volume)\n\n  const scanAxisNormal = direction.slice(6, 9);\n\n  // check if viewPlaneNormal is parallel to scanAxisNormal\n  const cross = vec3.cross(vec3.create(), viewPlaneNormal, scanAxisNormal);\n  const isAcquisitionPlane = vec3.length(cross) < EPSILON;\n\n  if (isAcquisitionPlane) {\n    const imageId = imageIds[imageIndex];\n\n    if (!imageId) {\n      return {};\n    }\n\n    const { instanceNumber } = metaData.get('generalImageModule', imageId) || {};\n    return parseInt(instanceNumber);\n  }\n}\n\nfunction OverlayItem(props) {\n  const { instance, customization = {} } = props;\n  const { color, attribute, title, label, background } = customization;\n  const value = customization.contentF?.(props, customization) ?? instance?.[attribute];\n  if (value === undefined || value === null) {\n    return null;\n  }\n  return (\n    <div\n      className=\"overlay-item flex flex-row\"\n      style={{ color, background }}\n      title={title}\n    >\n      {label ? <span className=\"mr-1 shrink-0\">{label}</span> : null}\n      <span className=\"ml-0 mr-2 shrink-0\">{value}</span>\n    </div>\n  );\n}\n\n/**\n * Window Level / Center Overlay item\n * //\n */\nfunction VOIOverlayItem({ voi, customization }: OverlayItemProps) {\n  const { windowWidth, windowCenter } = voi;\n  if (typeof windowCenter !== 'number' || typeof windowWidth !== 'number') {\n    return null;\n  }\n\n  return (\n    <div\n      className=\"overlay-item flex flex-row\"\n      style={{ color: customization?.color }}\n    >\n      <span className=\"mr-0.5 shrink-0 opacity-[0.70]\">W:</span>\n      <span className=\"mr-2.5 shrink-0\">{windowWidth.toFixed(0)}</span>\n      <span className=\"mr-0.5 shrink-0 opacity-[0.70]\">L:</span>\n      <span className=\"shrink-0\">{windowCenter.toFixed(0)}</span>\n    </div>\n  );\n}\n\n/**\n * Zoom Level Overlay item\n */\nfunction ZoomOverlayItem({ scale, customization }: OverlayItemProps) {\n  return (\n    <div\n      className=\"overlay-item flex flex-row\"\n      style={{ color: (customization && customization.color) || undefined }}\n    >\n      <span className=\"mr-0.5 shrink-0 opacity-[0.70]\">Zoom:</span>\n      <span>{scale.toFixed(2)}x</span>\n    </div>\n  );\n}\n\n/**\n * Instance Number Overlay Item\n */\nfunction InstanceNumberOverlayItem({\n  instanceNumber,\n  imageSliceData,\n  customization,\n}: OverlayItemProps) {\n  const { imageIndex, numberOfSlices } = imageSliceData;\n\n  return (\n    <div\n      className=\"overlay-item flex flex-row\"\n      style={{ color: (customization && customization.color) || undefined }}\n    >\n      <span>\n        {instanceNumber !== undefined && instanceNumber !== null ? (\n          <>\n            <span className=\"mr-0.5 shrink-0 opacity-[0.70]\">I:</span>\n            <span>{`${instanceNumber} (${imageIndex + 1}/${numberOfSlices})`}</span>\n          </>\n        ) : (\n          `${imageIndex + 1}/${numberOfSlices}`\n        )}\n      </span>\n    </div>\n  );\n}\n\nCustomizableViewportOverlay.propTypes = {\n  viewportData: PropTypes.object,\n  imageIndex: PropTypes.number,\n  viewportId: PropTypes.string,\n};\n\nexport default CustomizableViewportOverlay;\n\nexport { CustomizableViewportOverlay };\n","import React, { useEffect, useState, useMemo } from 'react';\nimport classNames from 'classnames';\nimport { metaData, Enums, getEnabledElement } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/tools';\nimport { vec3 } from 'gl-matrix';\n\nimport './ViewportOrientationMarkers.css';\nimport { useViewportRendering } from '../../hooks';\nconst { getOrientationStringLPS, invertOrientationStringLPS } = utilities.orientation;\n\nfunction ViewportOrientationMarkers({\n  element,\n  viewportData,\n  imageSliceData,\n  viewportId,\n  servicesManager,\n  orientationMarkers = ['top', 'left'],\n}: withAppTypes) {\n  const [cameraModifiedTime, setCameraModifiedTime] = useState(0);\n  const { isViewportBackgroundLight: isLight } = useViewportRendering(viewportId);\n  const { cornerstoneViewportService } = servicesManager.services;\n\n  useEffect(() => {\n    const cameraModifiedListener = () => setCameraModifiedTime(Date.now());\n    element.addEventListener(Enums.Events.CAMERA_MODIFIED, cameraModifiedListener);\n\n    return () => {\n      element.removeEventListener(Enums.Events.CAMERA_MODIFIED, cameraModifiedListener);\n    };\n  }, [element]);\n\n  const markers = useMemo(() => {\n    if (!viewportData || cameraModifiedTime === 0) {\n      return '';\n    }\n\n    if (!element || !getEnabledElement(element)) {\n      console.log(`ViewportOrientationMarkers :: Viewport element not enabled (${viewportId})`);\n      return '';\n    }\n\n    const ohifViewport = cornerstoneViewportService.getViewportInfo(viewportId);\n\n    if (!ohifViewport) {\n      console.log(`ViewportOrientationMarkers :: No viewport (${viewportId})`);\n      return '';\n    }\n\n    if (viewportData.viewportType === 'stack') {\n      const imageIndex = imageSliceData.imageIndex;\n      const imageId = viewportData.data[0].imageIds?.[imageIndex];\n\n      // Workaround for below TODO stub\n      if (!imageId) {\n        return false;\n      }\n\n      const { isDefaultValueSetForRowCosine, isDefaultValueSetForColumnCosine } =\n        metaData.get('imagePlaneModule', imageId) || {};\n\n      if (isDefaultValueSetForColumnCosine || isDefaultValueSetForRowCosine) {\n        return '';\n      }\n    }\n\n    const { viewport } = getEnabledElement(element);\n    const p00 = viewport.canvasToWorld([0, 0]);\n    const p10 = viewport.canvasToWorld([1, 0]);\n    const p01 = viewport.canvasToWorld([0, 1]);\n    const rowCosines = vec3.sub(vec3.create(), p10, p00);\n    const columnCosines = vec3.sub(vec3.create(), p01, p00);\n\n    vec3.normalize(rowCosines, rowCosines);\n    vec3.normalize(columnCosines, columnCosines);\n\n    const markers = _getOrientationMarkers(rowCosines, columnCosines);\n\n    return orientationMarkers.map((m, index) => (\n      <div\n        className={classNames(\n          'overlay-text',\n          `${m}-mid orientation-marker`,\n          isLight ? 'text-neutral-dark/70' : 'text-neutral-light/70',\n          isLight ? 'shadow-light' : 'shadow-dark',\n          'text-base',\n          'leading-5'\n        )}\n        key={`${m}-mid orientation-marker`}\n      >\n        <div className=\"orientation-marker-value\">{markers[m]}</div>\n      </div>\n    ));\n  }, [viewportData, imageSliceData, cameraModifiedTime, orientationMarkers, element, isLight]);\n\n  return <div className=\"ViewportOrientationMarkers select-none\">{markers}</div>;\n}\n\n/**\n *\n * Computes the orientation labels on a Cornerstone-enabled Viewport element\n * when the viewport settings change (e.g. when a horizontal flip or a rotation occurs)\n *\n * @param {*} rowCosines\n * @param {*} columnCosines\n */\nfunction _getOrientationMarkers(rowCosines, columnCosines) {\n  const rowString = getOrientationStringLPS(rowCosines);\n  const columnString = getOrientationStringLPS(columnCosines);\n  const oppositeRowString = invertOrientationStringLPS(rowString);\n  const oppositeColumnString = invertOrientationStringLPS(columnString);\n\n  const markers = {\n    top: oppositeColumnString,\n    left: oppositeRowString,\n    right: rowString,\n    bottom: columnString,\n  };\n\n  return markers;\n}\n\nexport default ViewportOrientationMarkers;\n","import React, { useEffect, useState, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { Enums } from '@cornerstonejs/core';\n\nfunction ViewportImageSliceLoadingIndicator({ viewportData, element }) {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(false);\n\n  const loadIndicatorRef = useRef(null);\n  const imageIdToBeLoaded = useRef(null);\n\n  const setLoadingState = evt => {\n    clearTimeout(loadIndicatorRef.current);\n\n    loadIndicatorRef.current = setTimeout(() => {\n      setLoading(true);\n    }, 50);\n  };\n\n  const setFinishLoadingState = evt => {\n    clearTimeout(loadIndicatorRef.current);\n\n    setLoading(false);\n  };\n\n  const setErrorState = evt => {\n    clearTimeout(loadIndicatorRef.current);\n\n    if (imageIdToBeLoaded.current === evt.detail.imageId) {\n      setError(evt.detail.error);\n      imageIdToBeLoaded.current = null;\n    }\n  };\n\n  useEffect(() => {\n    element.addEventListener(Enums.Events.STACK_VIEWPORT_SCROLL, setLoadingState);\n    element.addEventListener(Enums.Events.IMAGE_LOAD_ERROR, setErrorState);\n    element.addEventListener(Enums.Events.STACK_NEW_IMAGE, setFinishLoadingState);\n\n    return () => {\n      element.removeEventListener(Enums.Events.STACK_VIEWPORT_SCROLL, setLoadingState);\n\n      element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, setFinishLoadingState);\n\n      element.removeEventListener(Enums.Events.IMAGE_LOAD_ERROR, setErrorState);\n    };\n  }, [element, viewportData]);\n\n  if (error) {\n    return (\n      <>\n        <div className=\"absolute top-0 left-0 h-full w-full bg-black opacity-50\">\n          <div className=\"transparent flex h-full w-full items-center justify-center\">\n            <p className=\"text-primary-light text-xl font-light\">\n              <h4>Error Loading Image</h4>\n              <p>An error has occurred.</p>\n              <p>{error}</p>\n            </p>\n          </div>\n        </div>\n      </>\n    );\n  }\n\n  if (loading) {\n    return (\n      // IMPORTANT: we need to use the pointer-events-none class to prevent the loading indicator from\n      // interacting with the mouse, since scrolling should propagate to the viewport underneath\n      <div className=\"pointer-events-none absolute top-0 left-0 h-full w-full bg-black opacity-50\">\n        <div className=\"transparent flex h-full w-full items-center justify-center\">\n          <p className=\"text-primary-light text-xl font-light\">Loading...</p>\n        </div>\n      </div>\n    );\n  }\n\n  return null;\n}\n\nViewportImageSliceLoadingIndicator.propTypes = {\n  error: PropTypes.object,\n  element: PropTypes.object,\n};\n\nexport default ViewportImageSliceLoadingIndicator;\n","import React, { useEffect, useState } from 'react';\n\nimport ViewportImageScrollbar from './ViewportImageScrollbar';\nimport CustomizableViewportOverlay from './CustomizableViewportOverlay';\nimport ViewportOrientationMarkers from './ViewportOrientationMarkers';\nimport ViewportImageSliceLoadingIndicator from './ViewportImageSliceLoadingIndicator';\n\nfunction CornerstoneOverlays(props: withAppTypes) {\n  const { viewportId, element, scrollbarHeight, servicesManager } = props;\n  const { cornerstoneViewportService } = servicesManager.services;\n  const [imageSliceData, setImageSliceData] = useState({\n    imageIndex: 0,\n    numberOfSlices: 0,\n  });\n  const [viewportData, setViewportData] = useState(null);\n\n  useEffect(() => {\n    const { unsubscribe } = cornerstoneViewportService.subscribe(\n      cornerstoneViewportService.EVENTS.VIEWPORT_DATA_CHANGED,\n      props => {\n        if (props.viewportId !== viewportId) {\n          return;\n        }\n\n        setViewportData(props.viewportData);\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [viewportId]);\n\n  if (!element) {\n    return null;\n  }\n\n  if (viewportData) {\n    const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\n\n    if (viewportInfo?.viewportOptions?.customViewportProps?.hideOverlays) {\n      return null;\n    }\n  }\n\n  return (\n    <div className=\"noselect\">\n      <ViewportImageScrollbar\n        viewportId={viewportId}\n        viewportData={viewportData}\n        element={element}\n        imageSliceData={imageSliceData}\n        setImageSliceData={setImageSliceData}\n        scrollbarHeight={scrollbarHeight}\n        servicesManager={servicesManager}\n      />\n\n      <CustomizableViewportOverlay\n        imageSliceData={imageSliceData}\n        viewportData={viewportData}\n        viewportId={viewportId}\n        servicesManager={servicesManager}\n        element={element}\n      />\n\n      <ViewportImageSliceLoadingIndicator\n        viewportData={viewportData}\n        element={element}\n      />\n\n      <ViewportOrientationMarkers\n        imageSliceData={imageSliceData}\n        element={element}\n        viewportData={viewportData}\n        servicesManager={servicesManager}\n        viewportId={viewportId}\n      />\n    </div>\n  );\n}\n\nexport default CornerstoneOverlays;\n","import React, { useCallback, useEffect, useState, useRef } from 'react';\nimport { useCine } from '@ohif/ui-next';\nimport { Enums, eventTarget, cache } from '@cornerstonejs/core';\nimport { useAppConfig } from '@state';\n\nfunction WrappedCinePlayer({\n  enabledVPElement,\n  viewportId,\n  servicesManager,\n}: withAppTypes<{\n  enabledVPElement: HTMLElement;\n  viewportId: string;\n}>) {\n  const { customizationService, displaySetService, viewportGridService } = servicesManager.services;\n  const [{ isCineEnabled, cines }, cineService] = useCine();\n  const [newStackFrameRate, setNewStackFrameRate] = useState(24);\n  const [dynamicInfo, setDynamicInfo] = useState(null);\n  const [appConfig] = useAppConfig();\n  const isMountedRef = useRef(null);\n\n  const cineHandler = () => {\n    if (!cines?.[viewportId] || !enabledVPElement) {\n      return;\n    }\n\n    const { isPlaying = false, frameRate = 24 } = cines[viewportId];\n    const validFrameRate = Math.max(frameRate, 1);\n\n    return isPlaying\n      ? cineService.playClip(enabledVPElement, { framesPerSecond: validFrameRate, viewportId })\n      : cineService.stopClip(enabledVPElement);\n  };\n\n  const newDisplaySetHandler = useCallback(() => {\n    if (!enabledVPElement || !isCineEnabled) {\n      return;\n    }\n\n    const { viewports } = viewportGridService.getState();\n    const { displaySetInstanceUIDs } = viewports.get(viewportId);\n    let frameRate = 24;\n    let isPlaying = cines[viewportId]?.isPlaying || false;\n    displaySetInstanceUIDs.forEach(displaySetInstanceUID => {\n      const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n      if (displaySet.FrameRate) {\n        // displaySet.FrameRate corresponds to DICOM tag (0018,1063) which is defined as the the frame time in milliseconds\n        // So a bit of math to get the actual frame rate.\n        frameRate = Math.round(1000 / displaySet.FrameRate);\n        isPlaying ||= !!appConfig.autoPlayCine;\n      }\n\n      // check if the displaySet is dynamic and set the dynamic info\n      if (displaySet.isDynamicVolume) {\n        const { dynamicVolumeInfo } = displaySet;\n        const numDimensionGroups = dynamicVolumeInfo.timePoints.length;\n        const label = dynamicVolumeInfo.splittingTag;\n        const dimensionGroupNumber = dynamicVolumeInfo.dimensionGroupNumber || 1;\n        setDynamicInfo({\n          volumeId: displaySet.displaySetInstanceUID,\n          dimensionGroupNumber,\n          numDimensionGroups,\n          label,\n        });\n      } else {\n        setDynamicInfo(null);\n      }\n    });\n\n    if (isPlaying) {\n      cineService.setIsCineEnabled(isPlaying);\n    }\n    cineService.setCine({ id: viewportId, isPlaying, frameRate });\n    setNewStackFrameRate(frameRate);\n  }, [displaySetService, viewportId, viewportGridService, cines, isCineEnabled, enabledVPElement]);\n\n  useEffect(() => {\n    isMountedRef.current = true;\n\n    newDisplaySetHandler();\n\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, [isCineEnabled, newDisplaySetHandler]);\n\n  useEffect(() => {\n    if (!isCineEnabled) {\n      return;\n    }\n\n    cineHandler();\n  }, [isCineEnabled, cineHandler, enabledVPElement]);\n\n  /**\n   * Use effect for handling new display set\n   */\n  useEffect(() => {\n    if (!enabledVPElement) {\n      return;\n    }\n\n    enabledVPElement.addEventListener(Enums.Events.VIEWPORT_NEW_IMAGE_SET, newDisplaySetHandler);\n    // this doesn't makes sense that we are listening to this event on viewport element\n    enabledVPElement.addEventListener(\n      Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n      newDisplaySetHandler\n    );\n\n    return () => {\n      cineService.setCine({ id: viewportId, isPlaying: false });\n\n      enabledVPElement.removeEventListener(\n        Enums.Events.VIEWPORT_NEW_IMAGE_SET,\n        newDisplaySetHandler\n      );\n      enabledVPElement.removeEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        newDisplaySetHandler\n      );\n    };\n  }, [enabledVPElement, newDisplaySetHandler, viewportId]);\n\n  useEffect(() => {\n    if (!cines || !cines[viewportId] || !enabledVPElement || !isMountedRef.current) {\n      return;\n    }\n\n    cineHandler();\n\n    return () => {\n      cineService.stopClip(enabledVPElement, { viewportId });\n    };\n  }, [cines, viewportId, cineService, enabledVPElement, cineHandler]);\n\n  if (!isCineEnabled) {\n    return null;\n  }\n\n  const cine = cines[viewportId];\n  const isPlaying = cine?.isPlaying || false;\n\n  return (\n    <RenderCinePlayer\n      viewportId={viewportId}\n      cineService={cineService}\n      newStackFrameRate={newStackFrameRate}\n      isPlaying={isPlaying}\n      dynamicInfo={dynamicInfo}\n      customizationService={customizationService}\n    />\n  );\n}\n\nfunction RenderCinePlayer({\n  viewportId,\n  cineService,\n  newStackFrameRate,\n  isPlaying,\n  dynamicInfo: dynamicInfoProp,\n  customizationService,\n}) {\n  const CinePlayerComponent = customizationService.getCustomization('cinePlayer');\n\n  const [dynamicInfo, setDynamicInfo] = useState(dynamicInfoProp);\n\n  useEffect(() => {\n    setDynamicInfo(dynamicInfoProp);\n  }, [dynamicInfoProp]);\n\n  /**\n   * Use effect for handling 4D time index changed\n   */\n  useEffect(() => {\n    if (!dynamicInfo) {\n      return;\n    }\n\n    const handleDimensionGroupChange = evt => {\n      const { volumeId, dimensionGroupNumber, numDimensionGroups, splittingTag } = evt.detail;\n      setDynamicInfo({ volumeId, dimensionGroupNumber, numDimensionGroups, label: splittingTag });\n    };\n\n    eventTarget.addEventListener(\n      Enums.Events.DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED,\n      handleDimensionGroupChange\n    );\n\n    return () => {\n      eventTarget.removeEventListener(\n        Enums.Events.DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED,\n        handleDimensionGroupChange\n      );\n    };\n  }, [dynamicInfo]);\n\n  useEffect(() => {\n    if (!dynamicInfo) {\n      return;\n    }\n\n    const { volumeId, dimensionGroupNumber, numDimensionGroups, splittingTag } = dynamicInfo || {};\n    const volume = cache.getVolume(volumeId, true);\n    volume.dimensionGroupNumber = dimensionGroupNumber;\n\n    setDynamicInfo({ volumeId, dimensionGroupNumber, numDimensionGroups, label: splittingTag });\n  }, []);\n\n  const updateDynamicInfo = useCallback(props => {\n    const { volumeId, dimensionGroupNumber } = props;\n    const volume = cache.getVolume(volumeId, true);\n    volume.dimensionGroupNumber = dimensionGroupNumber;\n  }, []);\n\n  return (\n    <CinePlayerComponent\n      className=\"absolute left-1/2 bottom-3 -translate-x-1/2\"\n      frameRate={newStackFrameRate}\n      isPlaying={isPlaying}\n      onClose={() => {\n        // also stop the clip\n        cineService.setCine({\n          id: viewportId,\n          isPlaying: false,\n        });\n        cineService.setIsCineEnabled(false);\n        cineService.setViewportCineClosed(viewportId);\n      }}\n      onPlayPauseChange={isPlaying => {\n        cineService.setCine({\n          id: viewportId,\n          isPlaying,\n        });\n      }}\n      onFrameRateChange={frameRate =>\n        cineService.setCine({\n          id: viewportId,\n          frameRate,\n        })\n      }\n      dynamicInfo={dynamicInfo}\n      updateDynamicInfo={updateDynamicInfo}\n    />\n  );\n}\n\nexport default WrappedCinePlayer;","import CinePlayer from './CinePlayer';\n\nexport default CinePlayer;\n","import React, { memo } from 'react';\nimport { ViewportActionCorners, IconPresentationProvider, ToolButton } from '@ohif/ui-next';\nimport { Toolbar } from '@ohif/extension-default/src/Toolbar/Toolbar';\nimport { ButtonLocation } from '@ohif/core/src/services/ToolBarService/ToolbarService';\nimport { useViewportHover } from '../hooks';\n\nexport type OHIFViewportActionCornersProps = {\n  viewportId: string;\n};\n\nfunction OHIFViewportActionCornersComponent({ viewportId }: OHIFViewportActionCornersProps) {\n  // Use the viewport hover hook to track if viewport is hovered or active\n  const { isHovered, isActive } = useViewportHover(viewportId);\n\n  const shouldShowCorners = isHovered || isActive;\n\n  if (!shouldShowCorners) {\n    return null;\n  }\n\n  return (\n    <IconPresentationProvider\n      size=\"medium\"\n      IconContainer={ToolButton}\n      containerProps={{\n        size: 'tiny',\n        className: 'font-normal text-primary hover:bg-primary/25',\n      }}\n    >\n      <ViewportActionCorners.Container>\n        <ViewportActionCorners.TopLeft>\n          <Toolbar\n            buttonSection=\"viewportActionMenu.topLeft\"\n            viewportId={viewportId}\n            location={ButtonLocation.TopLeft}\n          />\n        </ViewportActionCorners.TopLeft>\n        <ViewportActionCorners.TopMiddle>\n          <Toolbar\n            buttonSection=\"viewportActionMenu.topMiddle\"\n            viewportId={viewportId}\n            location={ButtonLocation.TopMiddle}\n          />\n        </ViewportActionCorners.TopMiddle>\n        <ViewportActionCorners.TopRight>\n          <Toolbar\n            buttonSection=\"viewportActionMenu.topRight\"\n            viewportId={viewportId}\n            location={ButtonLocation.TopRight}\n          />\n        </ViewportActionCorners.TopRight>\n        <ViewportActionCorners.LeftMiddle>\n          <Toolbar\n            buttonSection=\"viewportActionMenu.leftMiddle\"\n            viewportId={viewportId}\n            location={ButtonLocation.LeftMiddle}\n          />\n        </ViewportActionCorners.LeftMiddle>\n        <ViewportActionCorners.RightMiddle>\n          <Toolbar\n            buttonSection=\"viewportActionMenu.rightMiddle\"\n            viewportId={viewportId}\n            location={ButtonLocation.RightMiddle}\n          />\n        </ViewportActionCorners.RightMiddle>\n        <ViewportActionCorners.BottomLeft>\n          <Toolbar\n            buttonSection=\"viewportActionMenu.bottomLeft\"\n            viewportId={viewportId}\n            location={ButtonLocation.BottomLeft}\n          />\n        </ViewportActionCorners.BottomLeft>\n        <ViewportActionCorners.BottomMiddle>\n          <Toolbar\n            buttonSection=\"viewportActionMenu.bottomMiddle\"\n            viewportId={viewportId}\n            location={ButtonLocation.BottomMiddle}\n          />\n        </ViewportActionCorners.BottomMiddle>\n        <ViewportActionCorners.BottomRight>\n          <Toolbar\n            buttonSection=\"viewportActionMenu.bottomRight\"\n            viewportId={viewportId}\n            location={ButtonLocation.BottomRight}\n          />\n        </ViewportActionCorners.BottomRight>\n      </ViewportActionCorners.Container>\n    </IconPresentationProvider>\n  );\n}\n\nconst OHIFViewportActionCorners = memo(OHIFViewportActionCornersComponent);\n\nexport default OHIFViewportActionCorners;\n","import { useEffect, useState, memo, useCallback } from 'react';\n\nconst ActiveViewportBehavior = memo(\n  ({ servicesManager, viewportId }: withAppTypes<{ viewportId: string }>) => {\n    const {\n      displaySetService,\n      cineService,\n      viewportGridService,\n      customizationService,\n      cornerstoneViewportService,\n    } = servicesManager.services;\n\n    const [activeViewportId, setActiveViewportId] = useState(viewportId);\n\n    const handleCineEnable = useCallback(() => {\n      if (cineService.isViewportCineClosed(activeViewportId)) {\n        return;\n      }\n\n      const displaySetInstanceUIDs =\n        viewportGridService.getDisplaySetsUIDsForViewport(activeViewportId);\n\n      if (!displaySetInstanceUIDs) {\n        return;\n      }\n\n      const displaySets = displaySetInstanceUIDs.map(uid =>\n        displaySetService.getDisplaySetByUID(uid)\n      );\n\n      if (!displaySets.length) {\n        return;\n      }\n\n      const modalities = displaySets.map(displaySet => displaySet?.Modality);\n      const isDynamicVolume = displaySets.some(displaySet => displaySet?.isDynamicVolume);\n\n      const sourceModalities = customizationService.getCustomization('autoCineModalities');\n\n      const requiresCine = modalities.some(modality => sourceModalities.includes(modality));\n\n      if ((requiresCine || isDynamicVolume) && !cineService.getState().isCineEnabled) {\n        cineService.setIsCineEnabled(true);\n      }\n    }, [\n      activeViewportId,\n      cineService,\n      viewportGridService,\n      displaySetService,\n      customizationService,\n    ]);\n\n    useEffect(() => {\n      const subscription = viewportGridService.subscribe(\n        viewportGridService.EVENTS.ACTIVE_VIEWPORT_ID_CHANGED,\n        ({ viewportId }) => setActiveViewportId(viewportId)\n      );\n\n      return () => subscription.unsubscribe();\n    }, [viewportId, viewportGridService]);\n\n    useEffect(() => {\n      const subscription = cornerstoneViewportService.subscribe(\n        cornerstoneViewportService.EVENTS.VIEWPORT_DATA_CHANGED,\n        () => {\n          const activeViewportId = viewportGridService.getActiveViewportId();\n          setActiveViewportId(activeViewportId);\n          handleCineEnable();\n        }\n      );\n\n      return () => subscription.unsubscribe();\n    }, [viewportId, cornerstoneViewportService, viewportGridService, handleCineEnable]);\n\n    useEffect(() => {\n      handleCineEnable();\n    }, [handleCineEnable]);\n\n    return null;\n  },\n  arePropsEqual\n);\n\nActiveViewportBehavior.displayName = 'ActiveViewportBehavior';\n\nfunction arePropsEqual(prevProps, nextProps) {\n  return (\n    prevProps.viewportId === nextProps.viewportId &&\n    prevProps.servicesManager === nextProps.servicesManager\n  );\n}\n\nexport default ActiveViewportBehavior;\n","import React, { useEffect, useRef, useCallback, useState } from 'react';\nimport * as cs3DTools from '@cornerstonejs/tools';\nimport { Enums, eventTarget, getEnabledElement } from '@cornerstonejs/core';\nimport { MeasurementService, useViewportRef } from '@ohif/core';\nimport { useViewportDialog } from '@ohif/ui-next';\nimport type { Types as csTypes } from '@cornerstonejs/core';\n\nimport { setEnabledElement } from '../state';\n\nimport './OHIFCornerstoneViewport.css';\nimport CornerstoneOverlays from './Overlays/CornerstoneOverlays';\nimport CinePlayer from '../components/CinePlayer';\nimport type { Types } from '@ohif/core';\n\nimport OHIFViewportActionCorners from '../components/OHIFViewportActionCorners';\nimport { getViewportPresentations } from '../utils/presentations/getViewportPresentations';\nimport { useSynchronizersStore } from '../stores/useSynchronizersStore';\nimport ActiveViewportBehavior from '../utils/ActiveViewportBehavior';\nimport { WITH_NAVIGATION } from '../services/ViewportService/CornerstoneViewportService';\n\nconst STACK = 'stack';\n\n// Cache for viewport dimensions, persists across component remounts\nconst viewportDimensions = new Map<string, { width: number; height: number }>();\n\n// Todo: This should be done with expose of internal API similar to react-vtkjs-viewport\n// Then we don't need to worry about the re-renders if the props change.\nconst OHIFCornerstoneViewport = React.memo(\n  (\n    props: withAppTypes<{\n      viewportId: string;\n      displaySets: AppTypes.DisplaySet[];\n      viewportOptions: AppTypes.ViewportGrid.GridViewportOptions;\n      initialImageIndex: number;\n    }>\n  ) => {\n    const {\n      displaySets,\n      dataSource,\n      viewportOptions,\n      displaySetOptions,\n      servicesManager,\n      onElementEnabled,\n      // eslint-disable-next-line react/prop-types\n      onElementDisabled,\n      isJumpToMeasurementDisabled = false,\n      // Note: you SHOULD NOT use the initialImageIdOrIndex for manipulation\n      // of the imageData in the OHIFCornerstoneViewport. This prop is used\n      // to set the initial state of the viewport's first image to render\n      // eslint-disable-next-line react/prop-types\n      initialImageIndex,\n      // if the viewport is part of a hanging protocol layout\n      // we should not really rely on the old synchronizers and\n      // you see below we only rehydrate the synchronizers if the viewport\n      // is not part of the hanging protocol layout. HPs should\n      // define their own synchronizers. Since the synchronizers are\n      // viewportId dependent and\n      // eslint-disable-next-line react/prop-types\n      isHangingProtocolLayout,\n    } = props;\n    const viewportId = viewportOptions.viewportId;\n\n    if (!viewportId) {\n      throw new Error('Viewport ID is required');\n    }\n\n    // Make sure displaySetOptions has one object per displaySet\n    while (displaySetOptions.length < displaySets.length) {\n      displaySetOptions.push({});\n    }\n\n    // Since we only have support for dynamic data in volume viewports, we should\n    // handle this case here and set the viewportType to volume if any of the\n    // displaySets are dynamic volumes\n    viewportOptions.viewportType = displaySets.some(\n      ds => ds.isDynamicVolume && ds.isReconstructable\n    )\n      ? 'volume'\n      : viewportOptions.viewportType;\n\n    const [scrollbarHeight, setScrollbarHeight] = useState('100px');\n    const [enabledVPElement, setEnabledVPElement] = useState(null);\n    const elementRef = useRef() as React.MutableRefObject<HTMLDivElement>;\n    const viewportRef = useViewportRef(viewportId);\n\n    const {\n      displaySetService,\n      toolbarService,\n      toolGroupService,\n      syncGroupService,\n      cornerstoneViewportService,\n      segmentationService,\n      cornerstoneCacheService,\n      customizationService,\n      measurementService,\n    } = servicesManager.services;\n\n    const [viewportDialogState] = useViewportDialog();\n    // useCallback for scroll bar height calculation\n    const setImageScrollBarHeight = useCallback(() => {\n      const scrollbarHeight = `${elementRef.current.clientHeight - 10}px`;\n      setScrollbarHeight(scrollbarHeight);\n    }, [elementRef]);\n\n    // useCallback for onResize\n    const onResize = useCallback(\n      (entries: ResizeObserverEntry[]) => {\n        if (elementRef.current && entries?.length) {\n          const entry = entries[0];\n          const { width, height } = entry.contentRect;\n\n          const prevDimensions = viewportDimensions.get(viewportId) || { width: 0, height: 0 };\n\n          // Check if dimensions actually changed and then only resize if they have changed\n          const hasDimensionsChanged =\n            prevDimensions.width !== width || prevDimensions.height !== height;\n\n          if (width > 0 && height > 0 && hasDimensionsChanged) {\n            viewportDimensions.set(viewportId, { width, height });\n            // Perform resize operations\n            cornerstoneViewportService.resize();\n            setImageScrollBarHeight();\n          }\n        }\n      },\n      [viewportId, elementRef, cornerstoneViewportService, setImageScrollBarHeight]\n    );\n\n    useEffect(() => {\n      const element = elementRef.current;\n      if (!element) {\n        return;\n      }\n\n      const resizeObserver = new ResizeObserver(onResize);\n      resizeObserver.observe(element);\n\n      // Cleanup function\n      return () => {\n        resizeObserver.unobserve(element);\n        resizeObserver.disconnect();\n      };\n    }, [onResize]);\n\n    const cleanUpServices = useCallback(\n      viewportInfo => {\n        const renderingEngineId = viewportInfo.getRenderingEngineId();\n        const syncGroups = viewportInfo.getSyncGroups();\n\n        toolGroupService.removeViewportFromToolGroup(viewportId, renderingEngineId);\n        syncGroupService.removeViewportFromSyncGroup(viewportId, renderingEngineId, syncGroups);\n\n        segmentationService.clearSegmentationRepresentations(viewportId);\n      },\n      [viewportId, segmentationService, syncGroupService, toolGroupService]\n    );\n\n    const elementEnabledHandler = useCallback(\n      evt => {\n        // check this is this element reference and return early if doesn't match\n        if (evt.detail.element !== elementRef.current) {\n          return;\n        }\n\n        const { viewportId, element } = evt.detail;\n        const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\n\n        if (!viewportInfo) {\n          return;\n        }\n\n        setEnabledElement(viewportId, element);\n        setEnabledVPElement(element);\n\n        const renderingEngineId = viewportInfo.getRenderingEngineId();\n        const toolGroupId = viewportInfo.getToolGroupId();\n        const syncGroups = viewportInfo.getSyncGroups();\n\n        toolGroupService.addViewportToToolGroup(viewportId, renderingEngineId, toolGroupId);\n\n        syncGroupService.addViewportToSyncGroup(viewportId, renderingEngineId, syncGroups);\n\n        // we don't need reactivity here so just use state\n        const { synchronizersStore } = useSynchronizersStore.getState();\n        if (synchronizersStore?.[viewportId]?.length && !isHangingProtocolLayout) {\n          // If the viewport used to have a synchronizer, re apply it again\n          _rehydrateSynchronizers(viewportId, syncGroupService);\n        }\n\n        if (onElementEnabled && typeof onElementEnabled === 'function') {\n          onElementEnabled(evt);\n        }\n      },\n      [viewportId, onElementEnabled, toolGroupService]\n    );\n\n    // disable the element upon unmounting\n    useEffect(() => {\n      cornerstoneViewportService.enableViewport(viewportId, elementRef.current);\n\n      eventTarget.addEventListener(Enums.Events.ELEMENT_ENABLED, elementEnabledHandler);\n\n      setImageScrollBarHeight();\n\n      return () => {\n        const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\n\n        if (!viewportInfo) {\n          return;\n        }\n\n        cornerstoneViewportService.storePresentation({ viewportId });\n\n        // This should be done after the store presentation since synchronizers\n        // will get cleaned up and they need the viewportInfo to be present\n        cleanUpServices(viewportInfo);\n\n        if (onElementDisabled && typeof onElementDisabled === 'function') {\n          onElementDisabled(viewportInfo);\n        }\n\n        cornerstoneViewportService.disableElement(viewportId);\n        viewportRef.unregister();\n\n        eventTarget.removeEventListener(Enums.Events.ELEMENT_ENABLED, elementEnabledHandler);\n      };\n    }, []);\n\n    // subscribe to displaySet metadata invalidation (updates)\n    // Currently, if the metadata changes we need to re-render the display set\n    // for it to take effect in the viewport. As we deal with scaling in the loading,\n    // we need to remove the old volume from the cache, and let the\n    // viewport to re-add it which will use the new metadata. Otherwise, the\n    // viewport will use the cached volume and the new metadata will not be used.\n    // Note: this approach does not actually end of sending network requests\n    // and it uses the network cache\n    useEffect(() => {\n      const { unsubscribe } = displaySetService.subscribe(\n        displaySetService.EVENTS.DISPLAY_SET_SERIES_METADATA_INVALIDATED,\n        async ({\n          displaySetInstanceUID: invalidatedDisplaySetInstanceUID,\n          invalidateData,\n        }: Types.DisplaySetSeriesMetadataInvalidatedEvent) => {\n          if (!invalidateData) {\n            return;\n          }\n\n          const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\n\n          if (viewportInfo.hasDisplaySet(invalidatedDisplaySetInstanceUID)) {\n            const viewportData = viewportInfo.getViewportData();\n            const newViewportData = await cornerstoneCacheService.invalidateViewportData(\n              viewportData,\n              invalidatedDisplaySetInstanceUID,\n              dataSource,\n              displaySetService\n            );\n\n            const keepCamera = true;\n            cornerstoneViewportService.updateViewport(viewportId, newViewportData, keepCamera);\n          }\n        }\n      );\n      return () => {\n        unsubscribe();\n      };\n    }, [viewportId]);\n\n    useEffect(() => {\n      // handle the default viewportType to be stack\n      if (!viewportOptions.viewportType) {\n        viewportOptions.viewportType = STACK;\n      }\n\n      const loadViewportData = async () => {\n        const viewportData = await cornerstoneCacheService.createViewportData(\n          displaySets,\n          viewportOptions,\n          dataSource,\n          initialImageIndex\n        );\n\n        const presentations = getViewportPresentations(viewportId, viewportOptions);\n\n        // Note: This is a hack to get the grid to re-render the OHIFCornerstoneViewport component\n        // Used for segmentation hydration right now, since the logic to decide whether\n        // a viewport needs to render a segmentation lives inside the CornerstoneViewportService\n        // so we need to re-render (force update via change of the needsRerendering) so that React\n        // does the diffing and decides we should render this again (although the id and element has not changed)\n        // so that the CornerstoneViewportService can decide whether to render the segmentation or not. Not that we reached here we can turn it off.\n        if (viewportOptions.needsRerendering) {\n          viewportOptions.needsRerendering = false;\n        }\n\n        cornerstoneViewportService.setViewportData(\n          viewportId,\n          viewportData,\n          viewportOptions,\n          displaySetOptions,\n          presentations\n        );\n      };\n\n      loadViewportData();\n    }, [viewportOptions, displaySets, dataSource]);\n\n    const Notification = customizationService.getCustomization('ui.notificationComponent');\n\n    return (\n      <React.Fragment>\n        <div className=\"viewport-wrapper\">\n          <div\n            className=\"cornerstone-viewport-element\"\n            style={{ height: '100%', width: '100%' }}\n            onContextMenu={e => e.preventDefault()}\n            onMouseDown={e => e.preventDefault()}\n            data-viewportid={viewportId}\n            ref={el => {\n              elementRef.current = el;\n              if (el) {\n                viewportRef.register(el);\n              }\n            }}\n          ></div>\n          <CornerstoneOverlays\n            viewportId={viewportId}\n            toolBarService={toolbarService}\n            element={elementRef.current}\n            scrollbarHeight={scrollbarHeight}\n            servicesManager={servicesManager}\n          />\n          <CinePlayer\n            enabledVPElement={enabledVPElement}\n            viewportId={viewportId}\n            servicesManager={servicesManager}\n          />\n          <ActiveViewportBehavior\n            viewportId={viewportId}\n            servicesManager={servicesManager}\n          />\n        </div>\n        {/* top offset of 24px to account for ViewportActionCorners. */}\n        <div className=\"absolute top-[24px] w-full\">\n          {viewportDialogState.viewportId === viewportId && (\n            <Notification\n              id=\"viewport-notification\"\n              message={viewportDialogState.message}\n              type={viewportDialogState.type}\n              actions={viewportDialogState.actions}\n              onSubmit={viewportDialogState.onSubmit}\n              onOutsideClick={viewportDialogState.onOutsideClick}\n              onKeyPress={viewportDialogState.onKeyPress}\n            />\n          )}\n        </div>\n        {/* The OHIFViewportActionCorners follows the viewport in the DOM so that it is naturally at a higher z-index.*/}\n        <OHIFViewportActionCorners viewportId={viewportId} />\n      </React.Fragment>\n    );\n  },\n  areEqual\n);\n\nfunction _rehydrateSynchronizers(viewportId: string, syncGroupService: any) {\n  const { synchronizersStore } = useSynchronizersStore.getState();\n  const synchronizers = synchronizersStore[viewportId];\n\n  if (!synchronizers) {\n    return;\n  }\n\n  synchronizers.forEach(synchronizerObj => {\n    if (!synchronizerObj.id) {\n      return;\n    }\n\n    const { id, sourceViewports, targetViewports } = synchronizerObj;\n\n    const synchronizer = syncGroupService.getSynchronizer(id);\n\n    if (!synchronizer) {\n      return;\n    }\n\n    const sourceViewportInfo = sourceViewports.find(\n      sourceViewport => sourceViewport.viewportId === viewportId\n    );\n\n    const targetViewportInfo = targetViewports.find(\n      targetViewport => targetViewport.viewportId === viewportId\n    );\n\n    const isSourceViewportInSynchronizer = synchronizer\n      .getSourceViewports()\n      .find(sourceViewport => sourceViewport.viewportId === viewportId);\n\n    const isTargetViewportInSynchronizer = synchronizer\n      .getTargetViewports()\n      .find(targetViewport => targetViewport.viewportId === viewportId);\n\n    // if the viewport was previously a source viewport, add it again\n    if (sourceViewportInfo && !isSourceViewportInSynchronizer) {\n      synchronizer.addSource({\n        viewportId: sourceViewportInfo.viewportId,\n        renderingEngineId: sourceViewportInfo.renderingEngineId,\n      });\n    }\n\n    // if the viewport was previously a target viewport, add it again\n    if (targetViewportInfo && !isTargetViewportInSynchronizer) {\n      synchronizer.addTarget({\n        viewportId: targetViewportInfo.viewportId,\n        renderingEngineId: targetViewportInfo.renderingEngineId,\n      });\n    }\n  });\n}\n\n// Component displayName\nOHIFCornerstoneViewport.displayName = 'OHIFCornerstoneViewport';\n\nfunction areEqual(prevProps, nextProps) {\n  if (nextProps.needsRerendering) {\n    return false;\n  }\n\n  if (prevProps.displaySets.length !== nextProps.displaySets.length) {\n    return false;\n  }\n\n  if (prevProps.viewportOptions.orientation !== nextProps.viewportOptions.orientation) {\n    return false;\n  }\n\n  if (prevProps.viewportOptions.toolGroupId !== nextProps.viewportOptions.toolGroupId) {\n    return false;\n  }\n\n  if (\n    nextProps.viewportOptions.viewportType &&\n    prevProps.viewportOptions.viewportType !== nextProps.viewportOptions.viewportType\n  ) {\n    return false;\n  }\n\n  if (nextProps.viewportOptions.needsRerendering) {\n    return false;\n  }\n\n  const prevDisplaySets = prevProps.displaySets;\n  const nextDisplaySets = nextProps.displaySets;\n\n  if (prevDisplaySets.length !== nextDisplaySets.length) {\n    return false;\n  }\n\n  for (let i = 0; i < prevDisplaySets.length; i++) {\n    const prevDisplaySet = prevDisplaySets[i];\n\n    const foundDisplaySet = nextDisplaySets.find(\n      nextDisplaySet =>\n        nextDisplaySet.displaySetInstanceUID === prevDisplaySet.displaySetInstanceUID\n    );\n\n    if (!foundDisplaySet) {\n      return false;\n    }\n\n    // check they contain the same image\n    if (foundDisplaySet.images?.length !== prevDisplaySet.images?.length) {\n      return false;\n    }\n\n    // check if their imageIds are the same\n    if (foundDisplaySet.images?.length) {\n      for (let j = 0; j < foundDisplaySet.images.length; j++) {\n        if (foundDisplaySet.images[j].imageId !== prevDisplaySet.images[j].imageId) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nexport default OHIFCornerstoneViewport;\n","import { usePositionPresentationStore } from '../../stores/usePositionPresentationStore';\nimport { useLutPresentationStore } from '../../stores/useLutPresentationStore';\nimport { useSegmentationPresentationStore } from '../../stores/useSegmentationPresentationStore';\n\nexport function getViewportPresentations(\n  viewportId: string,\n  viewportOptions: AppTypes.ViewportGrid.GridViewportOptions\n) {\n  const { lutPresentationStore } = useLutPresentationStore.getState();\n  const { positionPresentationStore } = usePositionPresentationStore.getState();\n  const { segmentationPresentationStore } = useSegmentationPresentationStore.getState();\n\n  // NOTE: this is the new viewport state, we should not get the presentationIds from the cornerstoneViewportService\n  // since that has the old viewport state\n  const { presentationIds } = viewportOptions;\n\n  if (!presentationIds) {\n    return {\n      positionPresentation: null,\n      lutPresentation: null,\n      segmentationPresentation: null,\n    };\n  }\n\n  const { lutPresentationId, positionPresentationId, segmentationPresentationId } = presentationIds;\n\n  const positionPresentation = positionPresentationStore[positionPresentationId];\n  const lutPresentation = lutPresentationStore[lutPresentationId];\n  const segmentationPresentation = segmentationPresentationStore[segmentationPresentationId];\n\n  return {\n    positionPresentation,\n    lutPresentation,\n    segmentationPresentation,\n  };\n}\n"],"names":["CornerstoneImageScrollbar","viewportData","viewportId","element","imageSliceData","setImageSliceData","scrollbarHeight","servicesManager","cineService","cornerstoneViewportService","services","useEffect","viewport","getCornerstoneViewport","VolumeViewport3D","imageIndex","getCurrentImageIdIndex","numberOfSlices","getNumberOfSlices","error","console","warn","viewportType","eventId","Enums","STACK","STACK_NEW_IMAGE","ORTHOGRAPHIC","VOLUME_NEW_IMAGE","IMAGE_RENDERED","updateIndex","event","newImageIdIndex","imageIdIndex","detail","addEventListener","removeEventListener","React","ImageScrollbar","onChange","evt","onImageScrollbarChange","isCineEnabled","getState","stopClip","setCine","id","isPlaying","csUtils","debounceLoading","max","height","value","propTypes","PropTypes","isRequired","Element","formatNumberPrecision","number","precision","parseFloat","toFixed","formatDICOMDate","date","strFormat","moment","format","formatDICOMTime","time","EPSILON","formatPN","utils","OverlayItemComponents","props","instance","customization","color","attribute","title","label","background","contentF","className","style","voi","windowWidth","windowCenter","scale","undefined","instanceNumber","CustomizableViewportOverlay","customizationService","toolGroupService","displaySetService","setVOI","useState","setScale","annotationState","setAnnotationState","isViewportBackgroundLight","isLight","useViewportRendering","topLeftCustomization","getCustomization","topRightCustomization","bottomLeftCustomization","bottomRightCustomization","useMemo","getInstanceNumber","displaySetProps","displaySets","data","length","map","datum","getDisplaySetByUID","displaySetInstanceUID","filter","it","getDisplaySets","displaySet","instances","referenceInstance","updateVOI","eventDetail","range","lower","upper","utilities","VOI_MODIFIED","annotationModified","useCallback","annotation","metadata","toolName","UltrasoundPleuraBLineTool","prevState","eventTarget","csToolsEnums","ANNOTATION_MODIFIED","updateScale","previousCamera","camera","parallelScale","getZoom","CAMERA_MODIFIED","_renderOverlayItem","item","overlayItemProps","formatters","formatDate","formatTime","inheritsFrom","OverlayItemComponent","renderItem","transform","getContent","keyPrefix","index","key","condition","ViewportOverlay","topLeft","topRight","bottomLeft","bottomRight","shadowClass","imageIds","imageId","generalImageModule","metaData","parseInt","_getInstanceNumberFromStack","volumes","volume","direction","cornerstoneViewport","getCamera","viewPlaneNormal","scanAxisNormal","slice","cross","vec3","_getInstanceNumberFromVolume","getOrientationStringLPS","invertOrientationStringLPS","orientationMarkers","cameraModifiedTime","setCameraModifiedTime","cameraModifiedListener","Date","now","markers","getEnabledElement","log","getViewportInfo","isDefaultValueSetForRowCosine","isDefaultValueSetForColumnCosine","p00","canvasToWorld","p10","p01","rowCosines","columnCosines","rowString","columnString","oppositeRowString","top","left","right","bottom","_getOrientationMarkers","m","classNames","ViewportImageSliceLoadingIndicator","loading","setLoading","setError","loadIndicatorRef","useRef","imageIdToBeLoaded","setLoadingState","clearTimeout","current","setTimeout","setFinishLoadingState","setErrorState","STACK_VIEWPORT_SCROLL","IMAGE_LOAD_ERROR","setViewportData","unsubscribe","subscribe","EVENTS","VIEWPORT_DATA_CHANGED","viewportInfo","viewportOptions","customViewportProps","hideOverlays","ViewportImageScrollbar","ViewportOrientationMarkers","RenderCinePlayer","newStackFrameRate","dynamicInfo","dynamicInfoProp","CinePlayerComponent","setDynamicInfo","handleDimensionGroupChange","volumeId","dimensionGroupNumber","numDimensionGroups","splittingTag","DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED","cache","getVolume","updateDynamicInfo","frameRate","onClose","setIsCineEnabled","setViewportCineClosed","onPlayPauseChange","onFrameRateChange","enabledVPElement","viewportGridService","cines","useCine","setNewStackFrameRate","appConfig","useAppConfig","isMountedRef","cineHandler","validFrameRate","Math","playClip","framesPerSecond","newDisplaySetHandler","viewports","displaySetInstanceUIDs","get","forEach","FrameRate","round","autoPlayCine","isDynamicVolume","dynamicVolumeInfo","timePoints","VIEWPORT_NEW_IMAGE_SET","VOLUME_VIEWPORT_NEW_VOLUME","cine","OHIFViewportActionCornersComponent","isHovered","isActive","useViewportHover","IconPresentationProvider","size","IconContainer","ToolButton","containerProps","ViewportActionCorners","Container","TopLeft","Toolbar","buttonSection","location","ButtonLocation","TopMiddle","TopRight","LeftMiddle","RightMiddle","BottomLeft","BottomMiddle","BottomRight","memo","ActiveViewportBehavior","activeViewportId","setActiveViewportId","handleCineEnable","isViewportCineClosed","getDisplaySetsUIDsForViewport","uid","modalities","Modality","some","sourceModalities","modality","includes","subscription","ACTIVE_VIEWPORT_ID_CHANGED","getActiveViewportId","arePropsEqual","prevProps","nextProps","displayName","viewportDimensions","Map","OHIFCornerstoneViewport","dataSource","displaySetOptions","onElementEnabled","onElementDisabled","isJumpToMeasurementDisabled","initialImageIndex","isHangingProtocolLayout","Error","push","ds","isReconstructable","setScrollbarHeight","setEnabledVPElement","elementRef","viewportRef","useViewportRef","toolbarService","syncGroupService","segmentationService","cornerstoneCacheService","measurementService","viewportDialogState","useViewportDialog","setImageScrollBarHeight","clientHeight","onResize","entries","entry","width","contentRect","prevDimensions","hasDimensionsChanged","set","resize","resizeObserver","ResizeObserver","observe","unobserve","disconnect","cleanUpServices","renderingEngineId","getRenderingEngineId","syncGroups","getSyncGroups","removeViewportFromToolGroup","removeViewportFromSyncGroup","clearSegmentationRepresentations","elementEnabledHandler","setEnabledElement","toolGroupId","getToolGroupId","addViewportToToolGroup","addViewportToSyncGroup","synchronizersStore","useSynchronizersStore","synchronizers","synchronizerObj","sourceViewports","targetViewports","synchronizer","getSynchronizer","sourceViewportInfo","find","sourceViewport","targetViewportInfo","targetViewport","isSourceViewportInSynchronizer","getSourceViewports","isTargetViewportInSynchronizer","getTargetViewports","addSource","addTarget","_rehydrateSynchronizers","enableViewport","ELEMENT_ENABLED","storePresentation","disableElement","unregister","DISPLAY_SET_SERIES_METADATA_INVALIDATED","async","invalidatedDisplaySetInstanceUID","invalidateData","hasDisplaySet","getViewportData","newViewportData","invalidateViewportData","keepCamera","updateViewport","createViewportData","presentations","lutPresentationStore","useLutPresentationStore","positionPresentationStore","usePositionPresentationStore","segmentationPresentationStore","useSegmentationPresentationStore","presentationIds","positionPresentation","lutPresentation","segmentationPresentation","lutPresentationId","positionPresentationId","segmentationPresentationId","getViewportPresentations","needsRerendering","loadViewportData","Notification","onContextMenu","e","preventDefault","onMouseDown","ref","el","register","CornerstoneOverlays","toolBarService","CinePlayer","message","type","actions","onSubmit","onOutsideClick","onKeyPress","OHIFViewportActionCorners","areEqual","orientation","prevDisplaySets","nextDisplaySets","i","prevDisplaySet","foundDisplaySet","nextDisplaySet","images","j"],"sourceRoot":""}