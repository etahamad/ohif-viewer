{"version":3,"file":"7197.bundle.2cadfb421a19a208b460.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-seg/src/id.js","webpack:///../../../extensions/cornerstone-dicom-seg/src/getSopClassHandlerModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/utils/dicomlabToRGB.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/commandsModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/index.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/getToolbarModule.ts"],"sourcesContent":["import packageJson from '../package.json';\n\nconst id = packageJson.name;\nconst SOPClassHandlerName = 'dicom-seg';\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\n\nexport { id, SOPClassHandlerId, SOPClassHandlerName };\n","import { utils, Types as OhifTypes } from '@ohif/core';\nimport i18n from '@ohif/i18n';\nimport { metaData, eventTarget } from '@cornerstonejs/core';\nimport { CONSTANTS, segmentation as cstSegmentation } from '@cornerstonejs/tools';\nimport { adaptersSEG, Enums } from '@cornerstonejs/adapters';\n\nimport { SOPClassHandlerId } from './id';\nimport { dicomlabToRGB } from './utils/dicomlabToRGB';\n\nconst sopClassUids = ['1.2.840.10008.5.1.4.1.1.66.4', '1.2.840.10008.5.1.4.1.1.66.7'];\n\nconst loadPromises = {};\n\nfunction _getDisplaySetsFromSeries(\n  instances,\n  servicesManager: AppTypes.ServicesManager,\n  extensionManager\n) {\n  const instance = instances[0];\n\n  const {\n    StudyInstanceUID,\n    SeriesInstanceUID,\n    SOPInstanceUID,\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPClassUID,\n    wadoRoot,\n    wadoUri,\n    wadoUriRoot,\n  } = instance;\n\n  const displaySet = {\n    Modality: 'SEG',\n    loading: false,\n    isReconstructable: false,\n    displaySetInstanceUID: utils.guid(),\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPInstanceUID,\n    SeriesInstanceUID,\n    StudyInstanceUID,\n    SOPClassHandlerId,\n    SOPClassUID,\n    referencedImages: null,\n    referencedSeriesInstanceUID: null,\n    referencedDisplaySetInstanceUID: null,\n    isDerivedDisplaySet: true,\n    isLoaded: false,\n    isHydrated: false,\n    segments: {},\n    sopClassUids,\n    instance,\n    instances: [instance],\n    wadoRoot,\n    wadoUriRoot,\n    wadoUri,\n    isOverlayDisplaySet: true,\n    label: SeriesDescription || `${i18n.t('Series')} ${SeriesNumber} - ${i18n.t('SEG')}`,\n  };\n\n  const referencedSeriesSequence = instance.ReferencedSeriesSequence;\n\n  if (!referencedSeriesSequence) {\n    console.error('ReferencedSeriesSequence is missing for the SEG');\n    return;\n  }\n\n  const referencedSeries = referencedSeriesSequence[0] || referencedSeriesSequence;\n\n  displaySet.referencedImages = instance.ReferencedSeriesSequence.ReferencedInstanceSequence;\n  displaySet.referencedSeriesInstanceUID = referencedSeries.SeriesInstanceUID;\n  const { displaySetService } = servicesManager.services;\n  const referencedDisplaySets = displaySetService.getDisplaySetsForSeries(\n    displaySet.referencedSeriesInstanceUID\n  );\n\n  const referencedDisplaySet = referencedDisplaySets[0];\n\n  if (!referencedDisplaySet) {\n    // subscribe to display sets added which means at some point it will be available\n    const { unsubscribe } = displaySetService.subscribe(\n      displaySetService.EVENTS.DISPLAY_SETS_ADDED,\n      ({ displaySetsAdded }) => {\n        // here we can also do a little bit of search, since sometimes DICOM SEG\n        // does not contain the referenced display set uid , and we can just\n        // see which of the display sets added is more similar and assign it\n        // to the referencedDisplaySet\n        const addedDisplaySet = displaySetsAdded[0];\n        if (addedDisplaySet.SeriesInstanceUID === displaySet.referencedSeriesInstanceUID) {\n          displaySet.referencedDisplaySetInstanceUID = addedDisplaySet.displaySetInstanceUID;\n          displaySet.isReconstructable = addedDisplaySet.isReconstructable;\n          unsubscribe();\n        }\n      }\n    );\n  } else {\n    displaySet.referencedDisplaySetInstanceUID = referencedDisplaySet.displaySetInstanceUID;\n    displaySet.isReconstructable = referencedDisplaySet.isReconstructable;\n  }\n\n  displaySet.load = async ({ headers }) =>\n    await _load(displaySet, servicesManager, extensionManager, headers);\n\n  return [displaySet];\n}\n\nfunction _load(\n  segDisplaySet,\n  servicesManager: AppTypes.ServicesManager,\n  extensionManager,\n  headers\n) {\n  const { SOPInstanceUID } = segDisplaySet;\n  const { segmentationService } = servicesManager.services;\n\n  if (\n    (segDisplaySet.loading || segDisplaySet.isLoaded) &&\n    loadPromises[SOPInstanceUID] &&\n    _segmentationExists(segDisplaySet)\n  ) {\n    return loadPromises[SOPInstanceUID];\n  }\n\n  segDisplaySet.loading = true;\n\n  // We don't want to fire multiple loads, so we'll wait for the first to finish\n  // and also return the same promise to any other callers.\n  loadPromises[SOPInstanceUID] = new Promise(async (resolve, reject) => {\n    if (!segDisplaySet.segments || Object.keys(segDisplaySet.segments).length === 0) {\n      try {\n        await _loadSegments({\n          extensionManager,\n          servicesManager,\n          segDisplaySet,\n          headers,\n        });\n      } catch (e) {\n        segDisplaySet.loading = false;\n        return reject(e);\n      }\n    }\n\n    segmentationService\n      .createSegmentationForSEGDisplaySet(segDisplaySet)\n      .then(() => {\n        segDisplaySet.loading = false;\n        resolve();\n      })\n      .catch(error => {\n        segDisplaySet.loading = false;\n        reject(error);\n      });\n  });\n\n  return loadPromises[SOPInstanceUID];\n}\n\nasync function _loadSegments({\n  extensionManager,\n  servicesManager,\n  segDisplaySet,\n  headers,\n}: withAppTypes) {\n  const utilityModule = extensionManager.getModuleEntry(\n    '@ohif/extension-cornerstone.utilityModule.common'\n  );\n\n  const { segmentationService, uiNotificationService } = servicesManager.services;\n\n  const { dicomLoaderService } = utilityModule.exports;\n  const arrayBuffer = await dicomLoaderService.findDicomDataPromise(segDisplaySet, null, headers);\n\n  const referencedDisplaySet = servicesManager.services.displaySetService.getDisplaySetByUID(\n    segDisplaySet.referencedDisplaySetInstanceUID\n  );\n\n  if (!referencedDisplaySet) {\n    throw new Error('referencedDisplaySet is missing for SEG');\n  }\n\n  let { imageIds } = referencedDisplaySet;\n\n  if (!imageIds) {\n    // try images\n    const { images } = referencedDisplaySet;\n    imageIds = images.map(image => image.imageId);\n  }\n\n  // Todo: what should be defaults here\n  const tolerance = 0.001;\n  eventTarget.addEventListener(Enums.Events.SEGMENTATION_LOAD_PROGRESS, evt => {\n    const { percentComplete } = evt.detail;\n    segmentationService._broadcastEvent(segmentationService.EVENTS.SEGMENT_LOADING_COMPLETE, {\n      percentComplete,\n    });\n  });\n\n  const results = await adaptersSEG.Cornerstone3D.Segmentation.createFromDICOMSegBuffer(\n    imageIds,\n    arrayBuffer,\n    { metadataProvider: metaData, tolerance }\n  );\n\n  let usedRecommendedDisplayCIELabValue = true;\n  results.segMetadata.data.forEach((data, i) => {\n    if (i > 0) {\n      data.rgba = data.RecommendedDisplayCIELabValue;\n\n      if (data.rgba) {\n        data.rgba = dicomlabToRGB(data.rgba);\n      } else {\n        usedRecommendedDisplayCIELabValue = false;\n        data.rgba = CONSTANTS.COLOR_LUT[i % CONSTANTS.COLOR_LUT.length];\n      }\n    }\n  });\n\n  if (!usedRecommendedDisplayCIELabValue) {\n    // Display a notification about the non-utilization of RecommendedDisplayCIELabValue\n    uiNotificationService.show({\n      title: 'DICOM SEG import',\n      message:\n        'RecommendedDisplayCIELabValue not found for one or more segments. The default color was used instead.',\n      type: 'warning',\n      duration: 5000,\n    });\n  }\n\n  Object.assign(segDisplaySet, results);\n}\n\nfunction _segmentationExists(segDisplaySet) {\n  return cstSegmentation.state.getSegmentation(segDisplaySet.displaySetInstanceUID);\n}\n\nfunction getSopClassHandlerModule(params: OhifTypes.Extensions.ExtensionParams) {\n  const { servicesManager, extensionManager } = params;\n  const getDisplaySetsFromSeries = instances => {\n    return _getDisplaySetsFromSeries(instances, servicesManager, extensionManager);\n  };\n\n  return [\n    {\n      name: 'dicom-seg',\n      sopClassUids,\n      getDisplaySetsFromSeries,\n    },\n  ];\n}\n\nexport default getSopClassHandlerModule;\n","import dcmjs from 'dcmjs';\n\n/**\n * Converts a CIELAB color to an RGB color using the dcmjs library.\n * @param cielab - The CIELAB color to convert.\n * @returns The RGB color as an array of three integers between 0 and 255.\n */\nfunction dicomlabToRGB(cielab: number[]): number[] {\n  const rgb = dcmjs.data.Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\n\n  return rgb;\n}\n\nexport { dicomlabToRGB };\n","import { Types } from '@ohif/core';\n\nconst segProtocol: Types.HangingProtocol.Protocol = {\n  id: '@ohif/seg',\n  // Don't store this hanging protocol as it applies to the currently active\n  // display set by default\n  // cacheId: null,\n  name: 'Segmentations',\n  // Just apply this one when specifically listed\n  protocolMatchingRules: [],\n  toolGroupIds: ['default'],\n  // -1 would be used to indicate active only, whereas other values are\n  // the number of required priors referenced - so 0 means active with\n  // 0 or more priors.\n  numberOfPriorsReferenced: 0,\n  // Default viewport is used to define the viewport when\n  // additional viewports are added using the layout tool\n  defaultViewport: {\n    viewportOptions: {\n      viewportType: 'stack',\n      toolGroupId: 'default',\n      allowUnmatchedView: true,\n      syncGroups: [\n        {\n          type: 'hydrateseg',\n          id: 'sameFORId',\n          source: true,\n          target: true,\n          // options: {\n          //   matchingRules: ['sameFOR'],\n          // },\n        },\n      ],\n    },\n    displaySets: [\n      {\n        id: 'segDisplaySetId',\n        matchedDisplaySetsIndex: -1,\n      },\n    ],\n  },\n  displaySetSelectors: {\n    segDisplaySetId: {\n      seriesMatchingRules: [\n        {\n          attribute: 'Modality',\n          constraint: {\n            equals: 'SEG',\n          },\n        },\n      ],\n    },\n  },\n  stages: [\n    {\n      name: 'Segmentations',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 1,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: {\n            allowUnmatchedView: true,\n            syncGroups: [\n              {\n                type: 'hydrateseg',\n                id: 'sameFORId',\n                source: true,\n                target: true,\n                // options: {\n                //   matchingRules: ['sameFOR'],\n                // },\n              },\n            ],\n          },\n          displaySets: [\n            {\n              id: 'segDisplaySetId',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\nfunction getHangingProtocolModule() {\n  return [\n    {\n      name: segProtocol.id,\n      protocol: segProtocol,\n    },\n  ];\n}\n\nexport default getHangingProtocolModule;\nexport { segProtocol };\n","import dcmjs from 'dcmjs';\nimport { classes, Types } from '@ohif/core';\nimport { cache, metaData } from '@cornerstonejs/core';\nimport { segmentation as cornerstoneToolsSegmentation } from '@cornerstonejs/tools';\nimport { adaptersRT, helpers, adaptersSEG } from '@cornerstonejs/adapters';\nimport { createReportDialogPrompt } from '@ohif/extension-default';\nimport { DicomMetadataStore } from '@ohif/core';\n\nimport PROMPT_RESPONSES from '../../default/src/utils/_shared/PROMPT_RESPONSES';\n\nconst { datasetToBlob } = dcmjs.data;\n\nconst getTargetViewport = ({ viewportId, viewportGridService }) => {\n  const { viewports, activeViewportId } = viewportGridService.getState();\n  const targetViewportId = viewportId || activeViewportId;\n\n  const viewport = viewports.get(targetViewportId);\n\n  return viewport;\n};\n\nconst {\n  Cornerstone3D: {\n    Segmentation: { generateSegmentation },\n  },\n} = adaptersSEG;\n\nconst {\n  Cornerstone3D: {\n    RTSS: { generateRTSSFromSegmentations },\n  },\n} = adaptersRT;\n\nconst { downloadDICOMData } = helpers;\n\nconst commandsModule = ({\n  servicesManager,\n  extensionManager,\n}: Types.Extensions.ExtensionParams): Types.Extensions.CommandsModule => {\n  const { segmentationService, displaySetService, viewportGridService, toolGroupService } =\n    servicesManager.services as AppTypes.Services;\n\n  const actions = {\n    /**\n     * Loads segmentations for a specified viewport.\n     * The function prepares the viewport for rendering, then loads the segmentation details.\n     * Additionally, if the segmentation has scalar data, it is set for the corresponding label map volume.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentations - Array of segmentations to be loaded.\n     * @param params.viewportId - the target viewport ID.\n     *\n     */\n    loadSegmentationsForViewport: async ({ segmentations, viewportId }) => {\n      // Todo: handle adding more than one segmentation\n      const viewport = getTargetViewport({ viewportId, viewportGridService });\n      const displaySetInstanceUID = viewport.displaySetInstanceUIDs[0];\n\n      const segmentation = segmentations[0];\n      const segmentationId = segmentation.segmentationId;\n      const label = segmentation.config.label;\n      const segments = segmentation.config.segments;\n\n      const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n      await segmentationService.createLabelmapForDisplaySet(displaySet, {\n        segmentationId,\n        segments,\n        label,\n      });\n\n      segmentationService.addOrUpdateSegmentation(segmentation);\n\n      await segmentationService.addSegmentationRepresentation(viewport.viewportId, {\n        segmentationId,\n      });\n\n      return segmentationId;\n    },\n    /**\n     * Generates a segmentation from a given segmentation ID.\n     * This function retrieves the associated segmentation and\n     * its referenced volume, extracts label maps from the\n     * segmentation volume, and produces segmentation data\n     * alongside associated metadata.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentationId - ID of the segmentation to be generated.\n     * @param params.options - Optional configuration for the generation process.\n     *\n     * @returns Returns the generated segmentation data.\n     */\n    generateSegmentation: ({ segmentationId, options = {} }) => {\n      const segmentation = cornerstoneToolsSegmentation.state.getSegmentation(segmentationId);\n\n      const { imageIds } = segmentation.representationData.Labelmap;\n\n      const segImages = imageIds.map(imageId => cache.getImage(imageId));\n      const referencedImages = segImages.map(image => cache.getImage(image.referencedImageId));\n\n      const labelmaps2D = [];\n\n      let z = 0;\n\n      for (const segImage of segImages) {\n        const segmentsOnLabelmap = new Set();\n        const pixelData = segImage.getPixelData();\n        const { rows, columns } = segImage;\n\n        // Use a single pass through the pixel data\n        for (let i = 0; i < pixelData.length; i++) {\n          const segment = pixelData[i];\n          if (segment !== 0) {\n            segmentsOnLabelmap.add(segment);\n          }\n        }\n\n        labelmaps2D[z++] = {\n          segmentsOnLabelmap: Array.from(segmentsOnLabelmap),\n          pixelData,\n          rows,\n          columns,\n        };\n      }\n\n      const allSegmentsOnLabelmap = labelmaps2D.map(labelmap => labelmap.segmentsOnLabelmap);\n\n      const labelmap3D = {\n        segmentsOnLabelmap: Array.from(new Set(allSegmentsOnLabelmap.flat())),\n        metadata: [],\n        labelmaps2D,\n      };\n\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\n      const representations = segmentationService.getRepresentationsForSegmentation(segmentationId);\n\n      Object.entries(segmentationInOHIF.segments).forEach(([segmentIndex, segment]) => {\n        // segmentation service already has a color for each segment\n        if (!segment) {\n          return;\n        }\n\n        const { label } = segment;\n\n        const firstRepresentation = representations[0];\n        const color = segmentationService.getSegmentColor(\n          firstRepresentation.viewportId,\n          segmentationId,\n          segment.segmentIndex\n        );\n\n        const RecommendedDisplayCIELabValue = dcmjs.data.Colors.rgb2DICOMLAB(\n          color.slice(0, 3).map(value => value / 255)\n        ).map(value => Math.round(value));\n\n        const segmentMetadata = {\n          SegmentNumber: segmentIndex.toString(),\n          SegmentLabel: label,\n          SegmentAlgorithmType: segment?.algorithmType || 'MANUAL',\n          SegmentAlgorithmName: segment?.algorithmName || 'OHIF Brush',\n          RecommendedDisplayCIELabValue,\n          SegmentedPropertyCategoryCodeSequence: {\n            CodeValue: 'T-D0050',\n            CodingSchemeDesignator: 'SRT',\n            CodeMeaning: 'Tissue',\n          },\n          SegmentedPropertyTypeCodeSequence: {\n            CodeValue: 'T-D0050',\n            CodingSchemeDesignator: 'SRT',\n            CodeMeaning: 'Tissue',\n          },\n        };\n        labelmap3D.metadata[segmentIndex] = segmentMetadata;\n      });\n\n      const generatedSegmentation = generateSegmentation(\n        referencedImages,\n        labelmap3D,\n        metaData,\n        options\n      );\n\n      return generatedSegmentation;\n    },\n    /**\n     * Downloads a segmentation based on the provided segmentation ID.\n     * This function retrieves the associated segmentation and\n     * uses it to generate the corresponding DICOM dataset, which\n     * is then downloaded with an appropriate filename.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentationId - ID of the segmentation to be downloaded.\n     *\n     */\n    downloadSegmentation: ({ segmentationId }) => {\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\n      const generatedSegmentation = actions.generateSegmentation({\n        segmentationId,\n      });\n\n      downloadDICOMData(generatedSegmentation.dataset, `${segmentationInOHIF.label}`);\n    },\n    /**\n     * Stores a segmentation based on the provided segmentationId into a specified data source.\n     * The SeriesDescription is derived from user input or defaults to the segmentation label,\n     * and in its absence, defaults to 'Research Derived Series'.\n     *\n     * @param {Object} params - Parameters for the function.\n     * @param params.segmentationId - ID of the segmentation to be stored.\n     * @param params.dataSource - Data source where the generated segmentation will be stored.\n     *\n     * @returns {Object|void} Returns the naturalized report if successfully stored,\n     * otherwise throws an error.\n     */\n    storeSegmentation: async ({ segmentationId, dataSource }) => {\n      const segmentation = segmentationService.getSegmentation(segmentationId);\n\n      if (!segmentation) {\n        throw new Error('No segmentation found');\n      }\n\n      const { label } = segmentation;\n      const defaultDataSource = dataSource ?? extensionManager.getActiveDataSource()[0];\n\n      const {\n        value: reportName,\n        dataSourceName: selectedDataSource,\n        action,\n      } = await createReportDialogPrompt({\n        servicesManager,\n        extensionManager,\n        title: 'Store Segmentation',\n      });\n\n      if (action === PROMPT_RESPONSES.CREATE_REPORT) {\n        try {\n          const selectedDataSourceConfig = selectedDataSource\n            ? extensionManager.getDataSources(selectedDataSource)[0]\n            : defaultDataSource;\n\n          const generatedData = actions.generateSegmentation({\n            segmentationId,\n            options: {\n              SeriesDescription: reportName || label || 'Research Derived Series',\n            },\n          });\n\n          if (!generatedData || !generatedData.dataset) {\n            throw new Error('Error during segmentation generation');\n          }\n\n          const { dataset: naturalizedReport } = generatedData;\n\n          // DCMJS assigns a dummy study id during creation, and this can cause problems, so clearing it out\n          if (naturalizedReport.StudyID === 'No Study ID') {\n            naturalizedReport.StudyID = '';\n          }\n\n          await selectedDataSourceConfig.store.dicom(naturalizedReport);\n\n          // add the information for where we stored it to the instance as well\n          naturalizedReport.wadoRoot = selectedDataSourceConfig.getConfig().wadoRoot;\n\n          DicomMetadataStore.addInstances([naturalizedReport], true);\n\n          return naturalizedReport;\n        } catch (error) {\n          console.debug('Error storing segmentation:', error);\n          throw error;\n        }\n      }\n    },\n    /**\n     * Converts segmentations into RTSS for download.\n     * This sample function retrieves all segentations and passes to\n     * cornerstone tool adapter to convert to DICOM RTSS format. It then\n     * converts dataset to downloadable blob.\n     *\n     */\n    downloadRTSS: async ({ segmentationId }) => {\n      const segmentations = segmentationService.getSegmentation(segmentationId);\n\n      // inject colors to the segmentIndex\n      const firstRepresentation =\n        segmentationService.getRepresentationsForSegmentation(segmentationId)[0];\n      Object.entries(segmentations.segments).forEach(([segmentIndex, segment]) => {\n        segment.color = segmentationService.getSegmentColor(\n          firstRepresentation.viewportId,\n          segmentationId,\n          segmentIndex\n        );\n      });\n\n      const RTSS = await generateRTSSFromSegmentations(\n        segmentations,\n        classes.MetadataProvider,\n        DicomMetadataStore\n      );\n\n      try {\n        const reportBlob = datasetToBlob(RTSS);\n\n        //Create a URL for the binary.\n        const objectUrl = URL.createObjectURL(reportBlob);\n        window.location.assign(objectUrl);\n      } catch (e) {\n        console.warn(e);\n      }\n    },\n  };\n\n  const definitions = {\n    loadSegmentationsForViewport: {\n      commandFn: actions.loadSegmentationsForViewport,\n    },\n\n    generateSegmentation: {\n      commandFn: actions.generateSegmentation,\n    },\n    downloadSegmentation: {\n      commandFn: actions.downloadSegmentation,\n    },\n    storeSegmentation: {\n      commandFn: actions.storeSegmentation,\n    },\n    downloadRTSS: {\n      commandFn: actions.downloadRTSS,\n    },\n  };\n\n  return {\n    actions,\n    definitions,\n    defaultContext: 'SEGMENTATION',\n  };\n};\n\nexport default commandsModule;\n","import { id } from './id';\nimport React from 'react';\n\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\nimport getHangingProtocolModule from './getHangingProtocolModule';\nimport getCommandsModule from './commandsModule';\nimport { getToolbarModule } from './getToolbarModule';\n\nconst Component = React.lazy(() => {\n  return import(/* webpackPrefetch: true */ './viewports/OHIFCornerstoneSEGViewport');\n});\n\nconst OHIFCornerstoneSEGViewport = props => {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <Component {...props} />\n    </React.Suspense>\n  );\n};\n\n/**\n * You can remove any of the following modules if you don't need them.\n */\nconst extension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   * You ID can be anything you want, but it should be unique.\n   */\n  id,\n  getCommandsModule,\n  getToolbarModule,\n  getViewportModule({ servicesManager, extensionManager, commandsManager }) {\n    const ExtendedOHIFCornerstoneSEGViewport = props => {\n      return (\n        <OHIFCornerstoneSEGViewport\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          commandsManager={commandsManager}\n          {...props}\n        />\n      );\n    };\n\n    return [{ name: 'dicom-seg', component: ExtendedOHIFCornerstoneSEGViewport }];\n  },\n  /**\n   * SopClassHandlerModule should provide a list of sop class handlers that will be\n   * available in OHIF for Modes to consume and use to create displaySets from Series.\n   * Each sop class handler is defined by a { name, sopClassUids, getDisplaySetsFromSeries}.\n   * Examples include the default sop class handler provided by the default extension\n   */\n  getSopClassHandlerModule,\n  getHangingProtocolModule,\n};\n\nexport default extension;\n","export function getToolbarModule({ servicesManager }: withAppTypes) {\n  const { segmentationService, toolbarService, toolGroupService } = servicesManager.services;\n  return [\n    {\n      name: 'evaluate.cornerstone.hasSegmentation',\n      evaluate: ({ viewportId }) => {\n        const segmentations = segmentationService.getSegmentationRepresentations(viewportId);\n        return {\n          disabled: !segmentations?.length,\n        };\n      },\n    },\n    {\n      name: 'evaluate.cornerstone.segmentation',\n      evaluate: ({ viewportId, button, toolNames, disabledText }) => {\n        // Todo: we need to pass in the button section Id since we are kind of\n        // forcing the button to have black background since initially\n        // it is designed for the toolbox not the toolbar on top\n        // we should then branch the buttonSectionId to have different styles\n        const segmentations = segmentationService.getSegmentationRepresentations(viewportId);\n        if (!segmentations?.length) {\n          return {\n            disabled: true,\n            disabledText: disabledText ?? 'No segmentations available',\n          };\n        }\n\n        const activeSegmentation = segmentationService.getActiveSegmentation(viewportId);\n        if (!Object.keys(activeSegmentation.segments).length) {\n          return {\n            disabled: true,\n            disabledText: 'Add segment to enable this tool',\n          };\n        }\n\n        const toolGroup = toolGroupService.getToolGroupForViewport(viewportId);\n\n        if (!toolGroup) {\n          return {\n            disabled: true,\n            disabledText: disabledText ?? 'Not available on the current viewport',\n          };\n        }\n\n        if (!toolNames) {\n          return {\n            disabled: false,\n            // isActive: false,\n          };\n        }\n\n        const toolName = toolbarService.getToolNameForButton(button);\n\n        if (!toolGroup.hasTool(toolName) && !toolNames) {\n          return {\n            disabled: true,\n            disabledText: disabledText ?? 'Not available on the current viewport',\n          };\n        }\n\n        const isPrimaryActive = toolNames\n          ? toolNames.includes(toolGroup.getActivePrimaryMouseButtonTool())\n          : toolGroup.getActivePrimaryMouseButtonTool() === toolName;\n\n        return {\n          disabled: false,\n          isActive: isPrimaryActive,\n        };\n      },\n    },\n  ];\n}\n"],"names":["id","packageJson","SOPClassHandlerId","sopClassUids","loadPromises","_getDisplaySetsFromSeries","instances","servicesManager","extensionManager","instance","StudyInstanceUID","SeriesInstanceUID","SOPInstanceUID","SeriesDescription","SeriesNumber","SeriesDate","SOPClassUID","wadoRoot","wadoUri","wadoUriRoot","displaySet","Modality","loading","isReconstructable","displaySetInstanceUID","utils","guid","referencedImages","referencedSeriesInstanceUID","referencedDisplaySetInstanceUID","isDerivedDisplaySet","isLoaded","isHydrated","segments","isOverlayDisplaySet","label","i18n","t","referencedSeriesSequence","ReferencedSeriesSequence","console","error","referencedSeries","ReferencedInstanceSequence","displaySetService","services","referencedDisplaySet","getDisplaySetsForSeries","unsubscribe","subscribe","EVENTS","DISPLAY_SETS_ADDED","displaySetsAdded","addedDisplaySet","load","async","headers","segDisplaySet","segmentationService","cstSegmentation","_segmentationExists","Promise","resolve","reject","Object","keys","length","utilityModule","getModuleEntry","uiNotificationService","dicomLoaderService","exports","arrayBuffer","findDicomDataPromise","getDisplaySetByUID","Error","imageIds","images","map","image","imageId","tolerance","eventTarget","addEventListener","Enums","SEGMENTATION_LOAD_PROGRESS","evt","percentComplete","detail","_broadcastEvent","SEGMENT_LOADING_COMPLETE","results","adaptersSEG","Cornerstone3D","Segmentation","createFromDICOMSegBuffer","metadataProvider","metaData","usedRecommendedDisplayCIELabValue","segMetadata","data","forEach","i","cielab","rgba","RecommendedDisplayCIELabValue","dcmjs","Colors","dicomlab2RGB","x","Math","round","CONSTANTS","show","title","message","type","duration","assign","_loadSegments","e","createSegmentationForSEGDisplaySet","then","catch","_load","params","name","getDisplaySetsFromSeries","segProtocol","protocolMatchingRules","toolGroupIds","numberOfPriorsReferenced","defaultViewport","viewportOptions","viewportType","toolGroupId","allowUnmatchedView","syncGroups","source","target","displaySets","matchedDisplaySetsIndex","displaySetSelectors","segDisplaySetId","seriesMatchingRules","attribute","constraint","equals","stages","viewportStructure","layoutType","properties","rows","columns","viewports","protocol","datasetToBlob","generateSegmentation","RTSS","generateRTSSFromSegmentations","adaptersRT","downloadDICOMData","helpers","commandsModule","viewportGridService","toolGroupService","actions","loadSegmentationsForViewport","segmentations","viewportId","viewport","getTargetViewport","activeViewportId","getState","targetViewportId","get","displaySetInstanceUIDs","segmentation","segmentationId","config","createLabelmapForDisplaySet","addOrUpdateSegmentation","addSegmentationRepresentation","options","cornerstoneToolsSegmentation","representationData","Labelmap","segImages","cache","getImage","referencedImageId","labelmaps2D","z","segImage","segmentsOnLabelmap","Set","pixelData","getPixelData","segment","add","Array","from","allSegmentsOnLabelmap","labelmap","labelmap3D","flat","metadata","segmentationInOHIF","getSegmentation","representations","getRepresentationsForSegmentation","entries","segmentIndex","firstRepresentation","color","getSegmentColor","rgb2DICOMLAB","slice","value","segmentMetadata","SegmentNumber","toString","SegmentLabel","SegmentAlgorithmType","algorithmType","SegmentAlgorithmName","algorithmName","SegmentedPropertyCategoryCodeSequence","CodeValue","CodingSchemeDesignator","CodeMeaning","SegmentedPropertyTypeCodeSequence","downloadSegmentation","generatedSegmentation","dataset","storeSegmentation","dataSource","defaultDataSource","getActiveDataSource","reportName","dataSourceName","selectedDataSource","action","createReportDialogPrompt","PROMPT_RESPONSES","CREATE_REPORT","selectedDataSourceConfig","getDataSources","generatedData","naturalizedReport","StudyID","store","dicom","getConfig","DicomMetadataStore","addInstances","debug","downloadRTSS","classes","MetadataProvider","reportBlob","objectUrl","URL","createObjectURL","window","location","warn","definitions","commandFn","defaultContext","Component","React","OHIFCornerstoneSEGViewport","props","fallback","getCommandsModule","getToolbarModule","toolbarService","evaluate","getSegmentationRepresentations","disabled","button","toolNames","disabledText","activeSegmentation","getActiveSegmentation","toolGroup","getToolGroupForViewport","toolName","getToolNameForButton","hasTool","isActive","includes","getActivePrimaryMouseButtonTool","getViewportModule","commandsManager","component","_extends","getSopClassHandlerModule","getHangingProtocolModule"],"sourceRoot":""}