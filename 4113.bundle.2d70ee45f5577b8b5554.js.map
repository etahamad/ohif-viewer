{"version":3,"file":"4113.bundle.2d70ee45f5577b8b5554.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-sr/src/enums.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/getRenderableData.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/toolNames.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/addSRAnnotation.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/isRehydratable.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/id.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/getSopClassHandlerModule.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/getFilteredCornerstoneToolState.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/getLabelFromDCMJSImportedToolData.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/hydrateStructuredReport.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/commandsModule.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/DICOMSRDisplayTool.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/SCOORD3DPointTool.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/SRSCOOR3DProbeMapper.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/addToolInstance.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/init.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/index.tsx","webpack:///../../../extensions/cornerstone-dicom-sr/src/onModeEnter.tsx","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/modules/dicomSRModule.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/createReferencedImageDisplaySet.ts"],"sourcesContent":["import { adaptersSR } from '@cornerstonejs/adapters';\n\nconst { CodeScheme: Cornerstone3DCodeScheme } = adaptersSR.Cornerstone3D;\n\nexport const SCOORDTypes = {\n  POINT: 'POINT',\n  MULTIPOINT: 'MULTIPOINT',\n  POLYLINE: 'POLYLINE',\n  CIRCLE: 'CIRCLE',\n  ELLIPSE: 'ELLIPSE',\n};\n\nexport const CodeNameCodeSequenceValues = {\n  ImagingMeasurementReport: '126000',\n  ImageLibrary: '111028',\n  ImagingMeasurements: '126010',\n  MeasurementGroup: '125007',\n  ImageLibraryGroup: '126200',\n  TrackingUniqueIdentifier: '112040',\n  TrackingIdentifier: '112039',\n  Finding: '121071',\n  FindingSite: 'G-C0E3', // SRT\n  FindingSiteSCT: '363698007', // SCT\n};\n\nexport const CodingSchemeDesignators = {\n  SRT: 'SRT',\n  SCT: 'SCT',\n  CornerstoneCodeSchemes: [Cornerstone3DCodeScheme.CodingSchemeDesignator, 'CST4'],\n};\n\nexport const RelationshipType = {\n  INFERRED_FROM: 'INFERRED FROM',\n  CONTAINS: 'CONTAINS',\n};\n\nconst enums = {\n  CodeNameCodeSequenceValues,\n  CodingSchemeDesignators,\n  RelationshipType,\n  SCOORDTypes,\n};\n\nexport default enums;\n","import { vec3 } from 'gl-matrix';\nimport { metaData, utilities, Types as csTypes } from '@cornerstonejs/core';\n\nimport { SCOORDTypes } from '../enums';\n\nconst EPSILON = 1e-4;\n\nconst getRenderableCoords = ({ GraphicData, ValueType, imageId }) => {\n  const renderableData = [];\n  if (ValueType === 'SCOORD3D') {\n    for (let i = 0; i < GraphicData.length; i += 3) {\n      renderableData.push([GraphicData[i], GraphicData[i + 1], GraphicData[i + 2]]);\n    }\n  } else {\n    for (let i = 0; i < GraphicData.length; i += 2) {\n      const worldPos = utilities.imageToWorldCoords(imageId, [GraphicData[i], GraphicData[i + 1]]);\n      renderableData.push(worldPos);\n    }\n  }\n  return renderableData;\n};\n\nfunction getRenderableData({ GraphicType, GraphicData, ValueType, imageId }) {\n  let renderableData = [];\n\n  switch (GraphicType) {\n    case SCOORDTypes.POINT:\n    case SCOORDTypes.MULTIPOINT:\n    case SCOORDTypes.POLYLINE: {\n      renderableData = getRenderableCoords({ GraphicData, ValueType, imageId });\n      break;\n    }\n    case SCOORDTypes.CIRCLE: {\n      const pointsWorld: csTypes.Point3[] = getRenderableCoords({\n        GraphicData,\n        ValueType,\n        imageId,\n      });\n\n      if (!imageId) {\n        // without the image id it's not possible to perform the calculations below\n        // these calculations also do not seem to be needed, since everything works\n        // just fine when we skip them. At least for SCOORD3D annotations.\n        return pointsWorld;\n      }\n\n      // We do not have an explicit draw circle svg helper in Cornerstone3D at\n      // this time, but we can use the ellipse svg helper to draw a circle, so\n      // here we reshape the data for that purpose.\n      const center = pointsWorld[0];\n      const onPerimeter = pointsWorld[1];\n      const radius = vec3.distance(center, onPerimeter);\n\n      const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n      if (!imagePlaneModule) {\n        throw new Error('No imagePlaneModule found');\n      }\n\n      const {\n        columnCosines,\n        rowCosines,\n      }: {\n        columnCosines: csTypes.Point3;\n        rowCosines: csTypes.Point3;\n      } = imagePlaneModule;\n\n      // we need to get major/minor axis (which are both the same size major = minor)\n\n      const firstAxisStart = vec3.create();\n      vec3.scaleAndAdd(firstAxisStart, center, columnCosines, radius);\n\n      const firstAxisEnd = vec3.create();\n      vec3.scaleAndAdd(firstAxisEnd, center, columnCosines, -radius);\n\n      const secondAxisStart = vec3.create();\n      vec3.scaleAndAdd(secondAxisStart, center, rowCosines, radius);\n\n      const secondAxisEnd = vec3.create();\n      vec3.scaleAndAdd(secondAxisEnd, center, rowCosines, -radius);\n\n      renderableData = [\n        firstAxisStart as csTypes.Point3,\n        firstAxisEnd as csTypes.Point3,\n        secondAxisStart as csTypes.Point3,\n        secondAxisEnd as csTypes.Point3,\n      ];\n\n      break;\n    }\n    case SCOORDTypes.ELLIPSE: {\n      // GraphicData is ordered as [majorAxisStartX, majorAxisStartY, majorAxisEndX, majorAxisEndY, minorAxisStartX, minorAxisStartY, minorAxisEndX, minorAxisEndY]\n      // But Cornerstone3D points are ordered as top, bottom, left, right for the\n      // ellipse so we need to identify if the majorAxis is horizontal or vertical\n      // and then choose the correct points to use for the ellipse.\n      const pointsWorld: csTypes.Point3[] = getRenderableCoords({\n        GraphicData,\n        ValueType,\n        imageId,\n      });\n\n      if (!imageId) {\n        // without the image id it's not possible to perform the calculations below\n        // these calculations also do not seem to be needed, since everything works\n        // just fine when we skip them. At least for SCOORD3D annotations.\n        return pointsWorld;\n      }\n\n      const majorAxisStart = vec3.fromValues(...pointsWorld[0]);\n      const majorAxisEnd = vec3.fromValues(...pointsWorld[1]);\n      const minorAxisStart = vec3.fromValues(...pointsWorld[2]);\n      const minorAxisEnd = vec3.fromValues(...pointsWorld[3]);\n\n      const majorAxisVec = vec3.create();\n      vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\n\n      // normalize majorAxisVec to avoid scaling issues\n      vec3.normalize(majorAxisVec, majorAxisVec);\n\n      const minorAxisVec = vec3.create();\n      vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\n      vec3.normalize(minorAxisVec, minorAxisVec);\n\n      const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n\n      if (!imagePlaneModule) {\n        throw new Error('imageId does not have imagePlaneModule metadata');\n      }\n\n      const { columnCosines }: { columnCosines: csTypes.Point3 } = imagePlaneModule;\n\n      // find which axis is parallel to the columnCosines\n      const columnCosinesVec = vec3.fromValues(...columnCosines);\n\n      const projectedMajorAxisOnColVec = Math.abs(vec3.dot(columnCosinesVec, majorAxisVec));\n      const projectedMinorAxisOnColVec = Math.abs(vec3.dot(columnCosinesVec, minorAxisVec));\n\n      const absoluteOfMajorDotProduct = Math.abs(projectedMajorAxisOnColVec);\n      const absoluteOfMinorDotProduct = Math.abs(projectedMinorAxisOnColVec);\n\n      renderableData = [];\n      if (Math.abs(absoluteOfMajorDotProduct - 1) < EPSILON) {\n        renderableData = [pointsWorld[0], pointsWorld[1], pointsWorld[2], pointsWorld[3]];\n      } else if (Math.abs(absoluteOfMinorDotProduct - 1) < EPSILON) {\n        renderableData = [pointsWorld[2], pointsWorld[3], pointsWorld[0], pointsWorld[1]];\n      } else {\n        console.warn('OBLIQUE ELLIPSE NOT YET SUPPORTED');\n      }\n      break;\n    }\n    default:\n      console.warn('Unsupported GraphicType:', GraphicType);\n  }\n\n  return renderableData;\n}\n\nexport default getRenderableData;\n","const toolNames = {\n  DICOMSRDisplay: 'DICOMSRDisplay',\n  SRLength: 'SRLength',\n  SRBidirectional: 'SRBidirectional',\n  SREllipticalROI: 'SREllipticalROI',\n  SRCircleROI: 'SRCircleROI',\n  SRArrowAnnotate: 'SRArrowAnnotate',\n  SRAngle: 'SRAngle',\n  SRCobbAngle: 'SRCobbAngle',\n  SRRectangleROI: 'SRRectangleROI',\n  SRPlanarFreehandROI: 'SRPlanarFreehandROI',\n  SRSCOORD3DPoint: 'SRSCOORD3DPoint',\n};\n\nexport default toolNames;\n","import { Types, annotation } from '@cornerstonejs/tools';\nimport { metaData } from '@cornerstonejs/core';\nimport { adaptersSR } from '@cornerstonejs/adapters';\n\nimport getRenderableData from './getRenderableData';\nimport toolNames from '../tools/toolNames';\n\nconst { MeasurementReport } = adaptersSR.Cornerstone3D;\n\nexport default function addSRAnnotation(measurement, imageId, frameNumber) {\n  let toolName = toolNames.DICOMSRDisplay;\n  const renderableData = measurement.coords.reduce((acc, coordProps) => {\n    acc[coordProps.GraphicType] = acc[coordProps.GraphicType] || [];\n    acc[coordProps.GraphicType].push(getRenderableData({ ...coordProps, imageId }));\n    return acc;\n  }, {});\n\n  const { TrackingUniqueIdentifier } = measurement;\n  const { ValueType: valueType, GraphicType: graphicType } = measurement.coords[0];\n  const graphicTypePoints = renderableData[graphicType];\n\n  /** TODO: Read the tool name from the DICOM SR identification type in the future. */\n  let frameOfReferenceUID = null;\n  let planeRestriction = null;\n\n  if (imageId) {\n    const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n    frameOfReferenceUID = imagePlaneModule?.frameOfReferenceUID;\n  }\n\n  if (valueType === 'SCOORD3D') {\n    const adapter = MeasurementReport.getAdapterForTrackingIdentifier(\n      measurement.TrackingIdentifier\n    );\n    if (!adapter) {\n      toolName = toolNames.SRSCOORD3DPoint;\n    }\n\n    // get the ReferencedFrameOfReferenceUID from the measurement\n    frameOfReferenceUID = measurement.coords[0].ReferencedFrameOfReferenceSequence;\n\n    planeRestriction = {\n      FrameOfReferenceUID: frameOfReferenceUID,\n      point: graphicTypePoints[0][0],\n    };\n  }\n\n  // Store the view reference for use in initial navigation\n  measurement.viewReference = {\n    planeRestriction,\n    FrameOfReferenceUID: frameOfReferenceUID,\n    referencedImageId: imageId,\n  };\n\n  const SRAnnotation: Types.Annotation = {\n    annotationUID: TrackingUniqueIdentifier,\n    highlighted: false,\n    isLocked: false,\n    invalidated: false,\n    metadata: {\n      toolName,\n      planeRestriction,\n      valueType,\n      graphicType,\n      FrameOfReferenceUID: frameOfReferenceUID,\n      referencedImageId: imageId,\n    },\n    data: {\n      label: measurement.labels?.[0]?.value || undefined,\n      displayText: measurement.displayText || undefined,\n      handles: {\n        textBox: measurement.textBox ?? {},\n        points: graphicTypePoints[0],\n      },\n      cachedStats: {},\n      frameNumber,\n      renderableData,\n      TrackingUniqueIdentifier,\n      labels: measurement.labels,\n    },\n  };\n\n  /**\n   * const annotationManager = annotation.annotationState.getAnnotationManager();\n   * was not triggering annotation_added events.\n   */\n  annotation.state.addAnnotation(SRAnnotation);\n}\n","import { adaptersSR } from '@cornerstonejs/adapters';\n\nconst { MeasurementReport } = adaptersSR.Cornerstone3D;\n\n/**\n * Checks if the given `displaySet`can be rehydrated into the `measurementService`.\n *\n * @param {object} displaySet The SR `displaySet` to check.\n * @param {object[]} mappings The CornerstoneTools 4 mappings to the `measurementService`.\n * @returns {boolean} True if the SR can be rehydrated into the `measurementService`.\n */\nexport default function isRehydratable(displaySet, mappings) {\n  if (!mappings || !mappings.length) {\n    return false;\n  }\n\n  const mappingDefinitions = new Set<string>();\n  for (const m of mappings) {\n    mappingDefinitions.add(m.annotationType);\n  }\n\n  const { measurements } = displaySet;\n\n  for (let i = 0; i < measurements.length; i++) {\n    const measurement = measurements[i];\n    if (!measurement) {\n      continue;\n    }\n    const { TrackingIdentifier = '', graphicType, graphicCode, pointsLength } = measurement;\n    if (!TrackingIdentifier && !graphicType) {\n      console.warn('No tracking identifier  or graphicType for measurement ', measurement);\n      continue;\n    }\n    const adapter = MeasurementReport.getAdapterForTrackingIdentifier(TrackingIdentifier);\n    const adapters = MeasurementReport.getAdaptersForTypes(graphicCode, graphicType, pointsLength);\n    const hydratable =\n      (adapter && mappingDefinitions.has(adapter.toolType)) ||\n      (adapters && adapters.some(adapter => mappingDefinitions.has(adapter.toolType)));\n\n    if (hydratable) {\n      return true;\n    }\n    console.log('Measurement is not rehydratable', TrackingIdentifier, measurements[i]);\n  }\n\n  console.log('No measurements found which were rehydratable');\n  return false;\n}\n","import packageJson from '../package.json';\n\nconst id = packageJson.name;\n\nconst SOPClassHandlerName = 'dicom-sr';\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\n\nconst SOPClassHandlerName3D = 'dicom-sr-3d';\nconst SOPClassHandlerId3D = `${id}.sopClassHandlerModule.${SOPClassHandlerName3D}`;\n\nexport { SOPClassHandlerName, SOPClassHandlerId, SOPClassHandlerName3D, SOPClassHandlerId3D, id };\n","import { utils, classes, DisplaySetService, Types as OhifTypes } from '@ohif/core';\nimport i18n from '@ohif/i18n';\nimport { Enums as CSExtensionEnums } from '@ohif/extension-cornerstone';\nimport { adaptersSR } from '@cornerstonejs/adapters';\n\nimport addSRAnnotation from './utils/addSRAnnotation';\nimport isRehydratable from './utils/isRehydratable';\nimport {\n  SOPClassHandlerName,\n  SOPClassHandlerId,\n  SOPClassHandlerId3D,\n  SOPClassHandlerName3D,\n} from './id';\nimport { CodeNameCodeSequenceValues, CodingSchemeDesignators } from './enums';\n\nconst { sopClassDictionary } = utils;\nconst { CORNERSTONE_3D_TOOLS_SOURCE_NAME, CORNERSTONE_3D_TOOLS_SOURCE_VERSION } = CSExtensionEnums;\nconst { MetadataProvider: metadataProvider } = classes;\nconst {\n  TEXT_ANNOTATION_POSITION,\n  COMMENT_CODE,\n  CodeScheme: Cornerstone3DCodeScheme,\n} = adaptersSR.Cornerstone3D;\n\ntype InstanceMetadata = Types.InstanceMetadata;\n\n/**\n * TODO\n * - [ ] Add SR thumbnail\n * - [ ] Make viewport\n * - [ ] Get stacks from referenced displayInstanceUID and load into wrapped CornerStone viewport\n */\n\nconst sopClassUids = [\n  sopClassDictionary.BasicTextSR,\n  sopClassDictionary.EnhancedSR,\n  sopClassDictionary.ComprehensiveSR,\n  sopClassDictionary.Comprehensive3DSR,\n];\n\nconst validateSameStudyUID = (uid: string, instances): void => {\n  instances.forEach(it => {\n    if (it.StudyInstanceUID !== uid) {\n      console.warn('Not all instances have the same UID', uid, it);\n      throw new Error(`Instances ${it.SOPInstanceUID} does not belong to ${uid}`);\n    }\n  });\n};\n\n/**\n * Adds instances to the DICOM SR series, rather than creating a new\n * series, so that as SR's are saved, they append to the series, and the\n * key image display set gets updated as well, containing just the new series.\n * @param instances is a list of instances from THIS series that are not\n *     in this DICOM SR Display Set already.\n */\nfunction addInstances(instances: InstanceMetadata[], _displaySetService: DisplaySetService) {\n  this.instances.push(...instances);\n  utils.sortStudyInstances(this.instances);\n  // The last instance is the newest one, so is the one most interesting.\n  // Eventually, the SR viewer should have the ability to choose which SR\n  // gets loaded, and to navigate among them.\n  this.instance = this.instances[this.instances.length - 1];\n  this.isLoaded = false;\n  return this;\n}\n\n/**\n * DICOM SR SOP Class Handler\n * For all referenced images in the TID 1500/300 sections, add an image to the\n * display.\n * @param instances is a set of instances all from the same series\n * @param servicesManager is the services that can be used for creating\n * @returns The list of display sets created for the given instances object\n */\nfunction _getDisplaySetsFromSeries(\n  instances,\n  servicesManager: AppTypes.ServicesManager,\n  extensionManager\n) {\n  // If the series has no instances, stop here\n  if (!instances || !instances.length) {\n    throw new Error('No instances were provided');\n  }\n\n  utils.sortStudyInstances(instances);\n  // The last instance is the newest one, so is the one most interesting.\n  // Eventually, the SR viewer should have the ability to choose which SR\n  // gets loaded, and to navigate among them.\n  const instance = instances[instances.length - 1];\n\n  const {\n    StudyInstanceUID,\n    SeriesInstanceUID,\n    SOPInstanceUID,\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SeriesTime,\n    ConceptNameCodeSequence,\n    SOPClassUID,\n  } = instance;\n  validateSameStudyUID(instance.StudyInstanceUID, instances);\n\n  const is3DSR = SOPClassUID === sopClassDictionary.Comprehensive3DSR;\n\n  const isImagingMeasurementReport =\n    ConceptNameCodeSequence?.CodeValue === CodeNameCodeSequenceValues.ImagingMeasurementReport;\n\n  const displaySet = {\n    Modality: 'SR',\n    displaySetInstanceUID: utils.guid(),\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SeriesTime,\n    SOPInstanceUID,\n    SeriesInstanceUID,\n    StudyInstanceUID,\n    SOPClassHandlerId: is3DSR ? SOPClassHandlerId3D : SOPClassHandlerId,\n    SOPClassUID,\n    instances,\n    referencedImages: null,\n    measurements: null,\n    isDerivedDisplaySet: true,\n    isLoaded: false,\n    isImagingMeasurementReport,\n    sopClassUids,\n    instance,\n    addInstances,\n    label: SeriesDescription || `${i18n.t('Series')} ${SeriesNumber} - ${i18n.t('SR')}`,\n  };\n\n  displaySet.load = () => _load(displaySet, servicesManager, extensionManager);\n\n  return [displaySet];\n}\n\n/**\n * Loads the display set with the given services and extension manager.\n * @param srDisplaySet - The display set to load.\n * @param servicesManager - The services manager containing displaySetService and measurementService.\n * @param extensionManager - The extension manager containing data sources.\n */\nasync function _load(\n  srDisplaySet: Types.DisplaySet,\n  servicesManager: AppTypes.ServicesManager,\n  extensionManager: AppTypes.ExtensionManager\n) {\n  const { displaySetService, measurementService } = servicesManager.services;\n  const dataSources = extensionManager.getDataSources();\n  const dataSource = dataSources[0];\n  const { ContentSequence } = srDisplaySet.instance;\n\n  async function retrieveBulkData(obj, parentObj = null, key = null) {\n    for (const prop in obj) {\n      if (typeof obj[prop] === 'object' && obj[prop] !== null) {\n        await retrieveBulkData(obj[prop], obj, prop);\n      } else if (Array.isArray(obj[prop])) {\n        await Promise.all(obj[prop].map(item => retrieveBulkData(item, obj, prop)));\n      } else if (prop === 'BulkDataURI') {\n        const value = await dataSource.retrieve.bulkDataURI({\n          BulkDataURI: obj[prop],\n          StudyInstanceUID: srDisplaySet.instance.StudyInstanceUID,\n          SeriesInstanceUID: srDisplaySet.instance.SeriesInstanceUID,\n          SOPInstanceUID: srDisplaySet.instance.SOPInstanceUID,\n        });\n        if (parentObj && key) {\n          parentObj[key] = new Float32Array(value);\n        }\n      }\n    }\n  }\n\n  if (srDisplaySet.isLoaded !== true) {\n    await retrieveBulkData(ContentSequence);\n  }\n\n  if (srDisplaySet.isImagingMeasurementReport) {\n    srDisplaySet.referencedImages = _getReferencedImagesList(ContentSequence);\n    srDisplaySet.measurements = _getMeasurements(ContentSequence);\n  } else {\n    srDisplaySet.referencedImages = [];\n    srDisplaySet.measurements = [];\n  }\n\n  const mappings = measurementService.getSourceMappings(\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\n  );\n\n  srDisplaySet.isHydrated = false;\n  srDisplaySet.isRehydratable = isRehydratable(srDisplaySet, mappings);\n  srDisplaySet.isLoaded = true;\n\n  /** Check currently added displaySets and add measurements if the sources exist */\n  displaySetService.activeDisplaySets.forEach(activeDisplaySet => {\n    _checkIfCanAddMeasurementsToDisplaySet(\n      srDisplaySet,\n      activeDisplaySet,\n      dataSource,\n      servicesManager\n    );\n  });\n\n  /** Subscribe to new displaySets as the source may come in after */\n  displaySetService.subscribe(displaySetService.EVENTS.DISPLAY_SETS_ADDED, data => {\n    const { displaySetsAdded } = data;\n    /**\n     * If there are still some measurements that have not yet been loaded into cornerstone,\n     * See if we can load them onto any of the new displaySets.\n     */\n    displaySetsAdded.forEach(newDisplaySet => {\n      _checkIfCanAddMeasurementsToDisplaySet(\n        srDisplaySet,\n        newDisplaySet,\n        dataSource,\n        servicesManager\n      );\n    });\n  });\n}\n\nfunction _measurementBelongsToDisplaySet({ measurement, displaySet }) {\n  return (\n    measurement.coords[0].ReferencedFrameOfReferenceSequence === displaySet.FrameOfReferenceUID\n  );\n}\n\n/**\n * Checks if measurements can be added to a display set.\n *\n * @param srDisplaySet - The source display set containing measurements.\n * @param newDisplaySet - The new display set to check if measurements can be added.\n * @param dataSource - The data source used to retrieve image IDs.\n * @param servicesManager - The services manager.\n */\nfunction _checkIfCanAddMeasurementsToDisplaySet(\n  srDisplaySet,\n  newDisplaySet,\n  dataSource,\n  servicesManager: AppTypes.ServicesManager\n) {\n  const { customizationService } = servicesManager.services;\n\n  const unloadedMeasurements = srDisplaySet.measurements.filter(\n    measurement => measurement.loaded === false\n  );\n\n  if (!unloadedMeasurements.length || newDisplaySet.unsupported) {\n    return;\n  }\n\n  // Create a Map to efficiently look up ImageIds by SOPInstanceUID and frame number\n  const imageIdMap = new Map<string, string>();\n  const imageIds = dataSource.getImageIdsForDisplaySet(newDisplaySet);\n\n  for (const imageId of imageIds) {\n    const { SOPInstanceUID, frameNumber } = metadataProvider.getUIDsFromImageID(imageId);\n    const key = `${SOPInstanceUID}:${frameNumber || 1}`;\n    imageIdMap.set(key, imageId);\n  }\n\n  if (!unloadedMeasurements?.length) {\n    return;\n  }\n\n  const is3DSR = srDisplaySet.SOPClassUID === sopClassDictionary.Comprehensive3DSR;\n\n  for (let j = unloadedMeasurements.length - 1; j >= 0; j--) {\n    let measurement = unloadedMeasurements[j];\n    const is3DMeasurement = measurement.coords?.[0]?.ValueType === 'SCOORD3D';\n\n    const onBeforeSRAddMeasurement = customizationService.getCustomization(\n      'onBeforeSRAddMeasurement'\n    );\n\n    if (typeof onBeforeSRAddMeasurement === 'function') {\n      measurement = onBeforeSRAddMeasurement({\n        measurement,\n        StudyInstanceUID: srDisplaySet.StudyInstanceUID,\n        SeriesInstanceUID: srDisplaySet.SeriesInstanceUID,\n      });\n    }\n\n    // if it is 3d SR we can just add the SR annotation\n    if (\n      is3DSR &&\n      is3DMeasurement &&\n      _measurementBelongsToDisplaySet({ measurement, displaySet: newDisplaySet })\n    ) {\n      _measurementBelongsToDisplaySet({ measurement, displaySet: newDisplaySet })\n\n      addSRAnnotation(measurement, null, null);\n      measurement.loaded = true;\n      measurement.displaySetInstanceUID = newDisplaySet.displaySetInstanceUID;\n      unloadedMeasurements.splice(j, 1);\n      continue;\n    }\n\n    const referencedSOPSequence = measurement.coords[0].ReferencedSOPSequence;\n    if (!referencedSOPSequence) {\n      continue;\n    }\n\n    const { ReferencedSOPInstanceUID } = referencedSOPSequence;\n    const frame = referencedSOPSequence.ReferencedFrameNumber || 1;\n    const key = `${ReferencedSOPInstanceUID}:${frame}`;\n    const imageId = imageIdMap.get(key);\n\n    if (\n      imageId &&\n      _measurementReferencesSOPInstanceUID(measurement, ReferencedSOPInstanceUID, frame)\n    ) {\n      addSRAnnotation(measurement, imageId, frame);\n\n      // Update measurement properties\n      measurement.loaded = true;\n      measurement.imageId = imageId;\n      measurement.displaySetInstanceUID = newDisplaySet.displaySetInstanceUID;\n      measurement.ReferencedSOPInstanceUID = ReferencedSOPInstanceUID;\n      measurement.frameNumber = frame;\n\n      unloadedMeasurements.splice(j, 1);\n    }\n  }\n}\n\n/**\n * Checks if a measurement references a specific SOP Instance UID.\n * @param measurement - The measurement object.\n * @param SOPInstanceUID - The SOP Instance UID to check against.\n * @param frameNumber - The frame number to check against (optional).\n * @returns True if the measurement references the specified SOP Instance UID, false otherwise.\n */\nfunction _measurementReferencesSOPInstanceUID(measurement, SOPInstanceUID, frameNumber) {\n  const { coords } = measurement;\n\n  /**\n   * NOTE: The ReferencedFrameNumber can be multiple values according to the DICOM\n   * Standard. But for now, we will support only one ReferenceFrameNumber.\n   */\n  const ReferencedFrameNumber =\n    (measurement.coords[0].ReferencedSOPSequence &&\n      measurement.coords[0].ReferencedSOPSequence?.ReferencedFrameNumber) ||\n    1;\n\n  if (frameNumber && Number(frameNumber) !== Number(ReferencedFrameNumber)) {\n    return false;\n  }\n\n  for (let j = 0; j < coords.length; j++) {\n    const coord = coords[j];\n    const { ReferencedSOPInstanceUID } = coord.ReferencedSOPSequence;\n    if (ReferencedSOPInstanceUID === SOPInstanceUID) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Retrieves the SOP class handler module.\n *\n * @param {Object} options - The options for retrieving the SOP class handler module.\n * @param {Object} options.servicesManager - The services manager.\n * @param {Object} options.extensionManager - The extension manager.\n * @returns {Array} An array containing the SOP class handler module.\n */\nfunction getSopClassHandlerModule(params: OhifTypes.Extensions.ExtensionParams) {\n  const { servicesManager, extensionManager } = params;\n  const getDisplaySetsFromSeries = instances => {\n    return _getDisplaySetsFromSeries(instances, servicesManager, extensionManager);\n  };\n  return [\n    {\n      name: SOPClassHandlerName,\n      sopClassUids,\n      getDisplaySetsFromSeries,\n    },\n    {\n      name: SOPClassHandlerName3D,\n      sopClassUids: [sopClassDictionary.Comprehensive3DSR],\n      getDisplaySetsFromSeries,\n    },\n  ];\n}\n\n/**\n * Retrieves the measurements from the ImagingMeasurementReportContentSequence.\n *\n * @param {Array} ImagingMeasurementReportContentSequence - The ImagingMeasurementReportContentSequence array.\n * @returns {Array} - The array of measurements.\n */\nfunction _getMeasurements(ImagingMeasurementReportContentSequence) {\n  const ImagingMeasurements = ImagingMeasurementReportContentSequence.find(\n    item =>\n      item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.ImagingMeasurements\n  );\n\n  if (!ImagingMeasurements) {\n    return [];\n  }\n\n  const MeasurementGroups = _getSequenceAsArray(ImagingMeasurements.ContentSequence).filter(\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.MeasurementGroup\n  );\n\n  const mergedContentSequencesByTrackingUniqueIdentifiers =\n    _getMergedContentSequencesByTrackingUniqueIdentifiers(MeasurementGroups);\n  const measurements = [];\n\n  Object.keys(mergedContentSequencesByTrackingUniqueIdentifiers).forEach(\n    trackingUniqueIdentifier => {\n      const mergedContentSequence =\n        mergedContentSequencesByTrackingUniqueIdentifiers[trackingUniqueIdentifier];\n\n      const measurement = _processMeasurement(mergedContentSequence);\n      if (measurement) {\n        measurements.push(measurement);\n      }\n    }\n  );\n\n  return measurements;\n}\n\n/**\n * Retrieves merged content sequences by tracking unique identifiers.\n *\n * @param {Array} MeasurementGroups - The measurement groups.\n * @returns {Object} - The merged content sequences by tracking unique identifiers.\n */\nfunction _getMergedContentSequencesByTrackingUniqueIdentifiers(MeasurementGroups) {\n  const mergedContentSequencesByTrackingUniqueIdentifiers = {};\n\n  MeasurementGroups.forEach(MeasurementGroup => {\n    const ContentSequence = _getSequenceAsArray(MeasurementGroup.ContentSequence);\n\n    const TrackingUniqueIdentifierItem = ContentSequence.find(\n      item =>\n        item.ConceptNameCodeSequence.CodeValue ===\n        CodeNameCodeSequenceValues.TrackingUniqueIdentifier\n    );\n    if (!TrackingUniqueIdentifierItem) {\n      console.warn('No Tracking Unique Identifier, skipping ambiguous measurement.');\n    }\n\n    const trackingUniqueIdentifier = TrackingUniqueIdentifierItem.UID;\n\n    if (mergedContentSequencesByTrackingUniqueIdentifiers[trackingUniqueIdentifier] === undefined) {\n      // Add the full ContentSequence\n      mergedContentSequencesByTrackingUniqueIdentifiers[trackingUniqueIdentifier] = [\n        ...ContentSequence,\n      ];\n    } else {\n      // Add the ContentSequence minus the tracking identifier, as we have this\n      // Information in the merged ContentSequence anyway.\n      ContentSequence.forEach(item => {\n        if (\n          item.ConceptNameCodeSequence.CodeValue !==\n          CodeNameCodeSequenceValues.TrackingUniqueIdentifier\n        ) {\n          mergedContentSequencesByTrackingUniqueIdentifiers[trackingUniqueIdentifier].push(item);\n        }\n      });\n    }\n  });\n\n  return mergedContentSequencesByTrackingUniqueIdentifiers;\n}\n\n/**\n * Processes the measurement based on the merged content sequence.\n * If the merged content sequence contains SCOORD or SCOORD3D value types,\n * it calls the _processTID1410Measurement function.\n * Otherwise, it calls the _processNonGeometricallyDefinedMeasurement function.\n *\n * @param {Array<Object>} mergedContentSequence - The merged content sequence to process.\n * @returns {any} - The processed measurement result.\n */\nfunction _processMeasurement(mergedContentSequence) {\n  if (mergedContentSequence.some(group => isScoordOr3d(group) && !isTextPosition(group))) {\n    return _processTID1410Measurement(mergedContentSequence);\n  }\n\n  return _processNonGeometricallyDefinedMeasurement(mergedContentSequence);\n}\n\n/**\n * Processes TID 1410 style measurements from the mergedContentSequence.\n * TID 1410 style measurements have a SCOORD or SCOORD3D at the top level,\n * and non-geometric representations where each NUM has \"INFERRED FROM\" SCOORD/SCOORD3D.\n *\n * @param mergedContentSequence - The merged content sequence containing the measurements.\n * @returns The measurement object containing the loaded status, labels, coordinates, tracking unique identifier, and tracking identifier.\n */\nfunction _processTID1410Measurement(mergedContentSequence) {\n  // Need to deal with TID 1410 style measurements, which will have a SCOORD or SCOORD3D at the top level,\n  // And non-geometric representations where each NUM has \"INFERRED FROM\" SCOORD/SCOORD3D\n\n  const graphicItem = mergedContentSequence.find(\n    group => group.ValueType === 'SCOORD' || group.ValueType === 'SCOORD3D'\n  );\n\n  const UIDREFContentItem = mergedContentSequence.find(group => group.ValueType === 'UIDREF');\n\n  const TrackingIdentifierContentItem = mergedContentSequence.find(\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.TrackingIdentifier\n  );\n\n  if (!graphicItem) {\n    console.warn(\n      `graphic ValueType ${graphicItem.ValueType} not currently supported, skipping annotation.`\n    );\n    return;\n  }\n\n  const NUMContentItems = mergedContentSequence.filter(group => group.ValueType === 'NUM');\n\n  const { ConceptNameCodeSequence: conceptNameItem } = graphicItem;\n  const { CodeValue: graphicValue, CodingSchemeDesignator: graphicDesignator } = conceptNameItem;\n  const graphicCode = `${graphicDesignator}:${graphicValue}`;\n\n  const pointDataItem = _getCoordsFromSCOORDOrSCOORD3D(graphicItem);\n  const is3DMeasurement = pointDataItem.ValueType === 'SCOORD3D';\n  const pointLength = is3DMeasurement ? 3 : 2;\n  const pointsLength = pointDataItem.GraphicData.length / pointLength;\n\n  const measurement = {\n    loaded: false,\n    labels: [],\n    coords: [pointDataItem],\n    TrackingUniqueIdentifier: UIDREFContentItem.UID,\n    TrackingIdentifier: TrackingIdentifierContentItem.TextValue,\n    graphicCode,\n    is3DMeasurement,\n    pointsLength,\n    graphicType: pointDataItem.GraphicType,\n  };\n\n  NUMContentItems.forEach(item => {\n    const { ConceptNameCodeSequence, MeasuredValueSequence } = item;\n    if (MeasuredValueSequence) {\n      measurement.labels.push(\n        _getLabelFromMeasuredValueSequence(ConceptNameCodeSequence, MeasuredValueSequence)\n      );\n    }\n  });\n\n  const findingSites = mergedContentSequence.filter(\n    item =>\n      item.ConceptNameCodeSequence.CodingSchemeDesignator === CodingSchemeDesignators.SCT &&\n      item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.FindingSiteSCT\n  );\n  if (findingSites.length) {\n    measurement.labels.push({\n      label: CodeNameCodeSequenceValues.FindingSiteSCT,\n      value: findingSites[0].ConceptCodeSequence.CodeMeaning,\n    });\n  }\n\n  return measurement;\n}\n\n/**\n * Processes the non-geometrically defined measurement from the merged content sequence.\n *\n * @param mergedContentSequence The merged content sequence containing the measurement data.\n * @returns The processed measurement object.\n */\nfunction _processNonGeometricallyDefinedMeasurement(mergedContentSequence) {\n  const NUMContentItems = mergedContentSequence.filter(group => group.ValueType === 'NUM');\n  const UIDREFContentItem = mergedContentSequence.find(group => group.ValueType === 'UIDREF');\n\n  const TrackingIdentifierContentItem = mergedContentSequence.find(\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.TrackingIdentifier\n  );\n\n  const finding = mergedContentSequence.find(\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.Finding\n  );\n\n  const findingSites = mergedContentSequence.filter(\n    item =>\n      item.ConceptNameCodeSequence.CodingSchemeDesignator === CodingSchemeDesignators.SRT &&\n      item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.FindingSite\n  );\n\n  const commentSites = mergedContentSequence.filter(\n    item =>\n      item.ConceptNameCodeSequence.CodingSchemeDesignator === COMMENT_CODE.schemeDesignator &&\n      item.ConceptNameCodeSequence.CodeValue === COMMENT_CODE.value\n  );\n\n  const measurement = {\n    loaded: false,\n    labels: [],\n    coords: [],\n    TrackingUniqueIdentifier: UIDREFContentItem.UID,\n    TrackingIdentifier: TrackingIdentifierContentItem.TextValue,\n  };\n\n  if (commentSites) {\n    for (const group of commentSites) {\n      if (group.TextValue) {\n        measurement.labels.push({ label: group.TextValue, value: '' });\n      }\n    }\n  }\n\n  if (\n    finding &&\n    CodingSchemeDesignators.CornerstoneCodeSchemes.includes(\n      finding.ConceptCodeSequence.CodingSchemeDesignator\n    ) &&\n    finding.ConceptCodeSequence.CodeValue === Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT\n  ) {\n    measurement.labels.push({\n      label: Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT,\n      value: finding.ConceptCodeSequence.CodeMeaning,\n    });\n  }\n\n  // TODO -> Eventually hopefully support SNOMED or some proper code library, just free text for now.\n  if (findingSites.length) {\n    const cornerstoneFreeTextFindingSite = findingSites.find(\n      FindingSite =>\n        CodingSchemeDesignators.CornerstoneCodeSchemes.includes(\n          FindingSite.ConceptCodeSequence.CodingSchemeDesignator\n        ) &&\n        FindingSite.ConceptCodeSequence.CodeValue ===\n          Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT\n    );\n\n    if (cornerstoneFreeTextFindingSite) {\n      measurement.labels.push({\n        label: Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT,\n        value: cornerstoneFreeTextFindingSite.ConceptCodeSequence.CodeMeaning,\n      });\n    }\n  }\n\n  NUMContentItems.forEach(item => {\n    const { ConceptNameCodeSequence, ContentSequence, MeasuredValueSequence } = item;\n\n    const { ValueType } = ContentSequence;\n    if (!ValueType === 'SCOORD') {\n      console.warn(`Graphic ${ValueType} not currently supported, skipping annotation.`);\n      return;\n    }\n\n    const coords = _getCoordsFromSCOORDOrSCOORD3D(ContentSequence);\n    if (coords) {\n      measurement.coords.push(coords);\n    }\n\n    if (MeasuredValueSequence) {\n      measurement.labels.push(\n        _getLabelFromMeasuredValueSequence(ConceptNameCodeSequence, MeasuredValueSequence)\n      );\n    }\n  });\n\n  return measurement;\n}\n\n/**\n * Extracts coordinates from a graphic item of type SCOORD or SCOORD3D.\n * @param {object} graphicItem - The graphic item containing the coordinates.\n * @returns {object} - The extracted coordinates.\n */\nconst _getCoordsFromSCOORDOrSCOORD3D = graphicItem => {\n  const { ValueType, GraphicType, GraphicData } = graphicItem;\n  const coords = { ValueType, GraphicType, GraphicData };\n  coords.ReferencedSOPSequence = graphicItem.ContentSequence?.ReferencedSOPSequence;\n  coords.ReferencedFrameOfReferenceSequence =\n    graphicItem.ReferencedFrameOfReferenceUID ||\n    graphicItem.ContentSequence?.ReferencedFrameOfReferenceSequence;\n  return coords;\n};\n\n/**\n * Retrieves the label and value from the provided ConceptNameCodeSequence and MeasuredValueSequence.\n * @param {Object} ConceptNameCodeSequence - The ConceptNameCodeSequence object.\n * @param {Object} MeasuredValueSequence - The MeasuredValueSequence object.\n * @returns {Object} - An object containing the label and value.\n *                    The label represents the CodeMeaning from the ConceptNameCodeSequence.\n *                    The value represents the formatted NumericValue and CodeValue from the MeasuredValueSequence.\n *                    Example: { label: 'Long Axis', value: '31.00 mm' }\n */\nfunction _getLabelFromMeasuredValueSequence(ConceptNameCodeSequence, MeasuredValueSequence) {\n  const { CodeMeaning } = ConceptNameCodeSequence;\n  const { NumericValue, MeasurementUnitsCodeSequence } = MeasuredValueSequence;\n  const { CodeValue } = MeasurementUnitsCodeSequence;\n  const formatedNumericValue = NumericValue ? Number(NumericValue).toFixed(2) : '';\n  return {\n    label: CodeMeaning,\n    value: `${formatedNumericValue} ${CodeValue}`,\n  }; // E.g. Long Axis: 31.0 mm\n}\n\n/**\n * Retrieves a list of referenced images from the Imaging Measurement Report Content Sequence.\n *\n * @param {Array} ImagingMeasurementReportContentSequence - The Imaging Measurement Report Content Sequence.\n * @returns {Array} - The list of referenced images.\n */\nfunction _getReferencedImagesList(ImagingMeasurementReportContentSequence) {\n  const ImageLibrary = ImagingMeasurementReportContentSequence.find(\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.ImageLibrary\n  );\n\n  if (!ImageLibrary) {\n    return [];\n  }\n\n  const ImageLibraryGroup = _getSequenceAsArray(ImageLibrary.ContentSequence).find(\n    item => item.ConceptNameCodeSequence.CodeValue === CodeNameCodeSequenceValues.ImageLibraryGroup\n  );\n  if (!ImageLibraryGroup) {\n    return [];\n  }\n\n  const referencedImages = [];\n\n  _getSequenceAsArray(ImageLibraryGroup.ContentSequence).forEach(item => {\n    const { ReferencedSOPSequence } = item;\n    if (!ReferencedSOPSequence) {\n      return;\n    }\n    for (const ref of _getSequenceAsArray(ReferencedSOPSequence)) {\n      if (ref.ReferencedSOPClassUID) {\n        const { ReferencedSOPClassUID, ReferencedSOPInstanceUID } = ref;\n\n        referencedImages.push({\n          ReferencedSOPClassUID,\n          ReferencedSOPInstanceUID,\n        });\n      }\n    }\n  });\n\n  return referencedImages;\n}\n\n/**\n * Converts a DICOM sequence to an array.\n * If the sequence is null or undefined, an empty array is returned.\n * If the sequence is already an array, it is returned as is.\n * Otherwise, the sequence is wrapped in an array and returned.\n *\n * @param {any} sequence - The DICOM sequence to convert.\n * @returns {any[]} - The converted array.\n */\nfunction _getSequenceAsArray(sequence) {\n  if (!sequence) {\n    return [];\n  }\n  return Array.isArray(sequence) ? sequence : [sequence];\n}\n\nfunction isScoordOr3d(group) {\n  return group.ValueType === 'SCOORD' || group.ValueType === 'SCOORD3D';\n}\n\nfunction isTextPosition(group) {\n  const concept = group.ConceptNameCodeSequence[0];\n  return (\n    concept &&\n    concept.CodeValue === TEXT_ANNOTATION_POSITION.value &&\n    concept.CodingSchemeDesignator === TEXT_ANNOTATION_POSITION.schemeDesignator\n  );\n}\n\nexport default getSopClassHandlerModule;\n","import { Types } from '@ohif/core';\n\nconst srProtocol: Types.HangingProtocol.Protocol = {\n  id: '@ohif/sr',\n  // Don't store this hanging protocol as it applies to the currently active\n  // display set by default\n  // cacheId: null,\n  name: 'SR Key Images',\n  // Just apply this one when specifically listed\n  protocolMatchingRules: [],\n  toolGroupIds: ['default'],\n  // -1 would be used to indicate active only, whereas other values are\n  // the number of required priors referenced - so 0 means active with\n  // 0 or more priors.\n  numberOfPriorsReferenced: 0,\n  // Default viewport is used to define the viewport when\n  // additional viewports are added using the layout tool\n  defaultViewport: {\n    viewportOptions: {\n      viewportType: 'stack',\n      toolGroupId: 'default',\n      allowUnmatchedView: true,\n    },\n    displaySets: [\n      {\n        id: 'srDisplaySetId',\n        matchedDisplaySetsIndex: -1,\n      },\n    ],\n  },\n  displaySetSelectors: {\n    srDisplaySetId: {\n      seriesMatchingRules: [\n        {\n          attribute: 'Modality',\n          constraint: {\n            equals: 'SR',\n          },\n        },\n      ],\n    },\n  },\n  stages: [\n    {\n      name: 'SR Key Images',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 1,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: { allowUnmatchedView: true },\n          displaySets: [\n            {\n              id: 'srDisplaySetId',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\nfunction getHangingProtocolModule() {\n  return [\n    {\n      name: srProtocol.id,\n      protocol: srProtocol,\n    },\n  ];\n}\n\nexport default getHangingProtocolModule;\nexport { srProtocol };\n","import { annotation } from '@cornerstonejs/tools';\nimport { NO_IMAGE_ID } from '@cornerstonejs/adapters';\n\nfunction getFilteredCornerstoneToolState(measurementData, additionalFindingTypes) {\n  const filteredToolState = {};\n\n  function addToFilteredToolState(annotation, toolType) {\n    const imageId = annotation.metadata?.referencedImageId ?? NO_IMAGE_ID;\n\n    if (!filteredToolState[imageId]) {\n      filteredToolState[imageId] = {};\n    }\n\n    const imageIdSpecificToolState = filteredToolState[imageId];\n\n    if (!imageIdSpecificToolState[toolType]) {\n      imageIdSpecificToolState[toolType] = {\n        data: [],\n      };\n    }\n\n    const measurementDataI = measurementData.find(md => md.uid === annotation.annotationUID);\n    const toolData = imageIdSpecificToolState[toolType].data;\n\n    let { finding } = measurementDataI;\n    const findingSites = [];\n\n    // NOTE -> We use the CORNERSTONEJS coding schemeDesignator which we have\n    // defined in the @cornerstonejs/adapters\n    if (measurementDataI.label) {\n      if (additionalFindingTypes.includes(toolType)) {\n        finding = {\n          CodeValue: 'CORNERSTONEFREETEXT',\n          CodingSchemeDesignator: 'CORNERSTONEJS',\n          CodeMeaning: measurementDataI.label,\n        };\n      } else {\n        findingSites.push({\n          CodeValue: 'CORNERSTONEFREETEXT',\n          CodingSchemeDesignator: 'CORNERSTONEJS',\n          CodeMeaning: measurementDataI.label,\n        });\n      }\n    }\n\n    if (measurementDataI.findingSites) {\n      findingSites.push(...measurementDataI.findingSites);\n    }\n\n    const measurement = Object.assign({}, annotation, {\n      finding,\n      findingSites,\n    });\n\n    toolData.push(measurement);\n  }\n\n  const uidFilter = measurementData.map(md => md.uid);\n  const uids = uidFilter.slice();\n\n  const annotationManager = annotation.state.getAnnotationManager();\n  const framesOfReference = annotationManager.getFramesOfReference();\n\n  for (let i = 0; i < framesOfReference.length; i++) {\n    const frameOfReference = framesOfReference[i];\n\n    const frameOfReferenceAnnotations = annotationManager.getAnnotations(frameOfReference);\n\n    const toolTypes = Object.keys(frameOfReferenceAnnotations);\n\n    for (let j = 0; j < toolTypes.length; j++) {\n      const toolType = toolTypes[j];\n\n      const annotations = frameOfReferenceAnnotations[toolType];\n\n      if (annotations) {\n        for (let k = 0; k < annotations.length; k++) {\n          const annotation = annotations[k];\n          const uidIndex = uids.findIndex(uid => uid === annotation.annotationUID);\n\n          if (uidIndex !== -1) {\n            addToFilteredToolState(annotation, toolType);\n            uids.splice(uidIndex, 1);\n\n            if (!uids.length) {\n              return filteredToolState;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return filteredToolState;\n}\n\nexport default getFilteredCornerstoneToolState;\n","import { adaptersSR } from '@cornerstonejs/adapters';\n\nconst { CodeScheme: Cornerstone3DCodeScheme } = adaptersSR.Cornerstone3D;\n\n/**\n * Extracts the label from the toolData imported from dcmjs. We need to do this\n * as dcmjs does not depeend on OHIF/the measurementService, it just produces data for cornestoneTools.\n * This optional data is available for the consumer to process if they wish to.\n * @param {object} toolData The tooldata relating to the\n *\n * @returns {string} The extracted label.\n */\nexport default function getLabelFromDCMJSImportedToolData(toolData) {\n  const { findingSites = [], finding, annotation } = toolData;\n\n  if (annotation.data.label) {\n    return annotation.data.label;\n  }\n\n  let freeTextLabel = findingSites.find(\n    fs => fs.CodeValue === Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT\n  );\n\n  if (freeTextLabel) {\n    return freeTextLabel.CodeMeaning;\n  }\n\n  if (finding && finding.CodeValue === Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT) {\n    return finding.CodeMeaning;\n  }\n}\n","import { utilities, metaData, type Types } from '@cornerstonejs/core';\nimport OHIF, { DicomMetadataStore } from '@ohif/core';\nimport { vec3 } from 'gl-matrix';\n\nimport getLabelFromDCMJSImportedToolData from './getLabelFromDCMJSImportedToolData';\nimport { adaptersSR } from '@cornerstonejs/adapters';\nimport { annotation as CsAnnotation, type Types as ToolTypes } from '@cornerstonejs/tools';\nimport { Enums as CSExtensionEnums } from '@ohif/extension-cornerstone';\n\nconst { locking } = CsAnnotation;\nconst { guid } = OHIF.utils;\nconst { MeasurementReport } = adaptersSR.Cornerstone3D;\nconst { CORNERSTONE_3D_TOOLS_SOURCE_NAME, CORNERSTONE_3D_TOOLS_SOURCE_VERSION } = CSExtensionEnums;\n\nconst convertCode = (codingValues, code) => {\n  if (!code || code.CodingSchemeDesignator === 'CORNERSTONEJS') {\n    return;\n  }\n  const ref = `${code.CodingSchemeDesignator}:${code.CodeValue}`;\n  const ret = { ...codingValues[ref], ref, ...code, text: code.CodeMeaning };\n  return ret;\n};\n\nconst convertSites = (codingValues, sites) => {\n  if (!sites || !sites.length) {\n    return;\n  }\n  const ret = [];\n  // Do as a loop to convert away from Proxy instances\n  for (let i = 0; i < sites.length; i++) {\n    // Deal with irregular conversion from dcmjs\n    const site = convertCode(codingValues, sites[i][0] || sites[i]);\n    if (site) {\n      ret.push(site);\n    }\n  }\n  return (ret.length && ret) || undefined;\n};\n\n/**\n * Hydrates a structured report\n * Handles 2d and 3d hydration from SCOORD and SCOORD3D points\n * For 3D hydration, chooses a volume display set to display with\n * FOr 2D hydration, chooses the (first) display set containing the referenced image.\n */\nexport default function hydrateStructuredReport(\n  { servicesManager, extensionManager, commandsManager }: withAppTypes,\n  displaySetInstanceUID\n) {\n  const dataSource = extensionManager.getActiveDataSource()[0];\n  const { measurementService, displaySetService, customizationService } = servicesManager.services;\n\n  const codingValues = customizationService.getCustomization('codingValues');\n  const disableEditing = customizationService.getCustomization('panelMeasurement.disableEditing');\n\n  const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n  // TODO -> We should define a strict versioning somewhere.\n  const mappings = measurementService.getSourceMappings(\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\n  );\n\n  if (!mappings || !mappings.length) {\n    throw new Error(\n      `Attempting to hydrate measurements service when no mappings present. This shouldn't be reached.`\n    );\n  }\n\n  const instance = DicomMetadataStore.getInstance(\n    displaySet.StudyInstanceUID,\n    displaySet.SeriesInstanceUID,\n    displaySet.SOPInstanceUID\n  );\n\n  const sopInstanceUIDToImageId = {};\n  const imageIdsForToolState = {};\n\n  displaySet.measurements.forEach(measurement => {\n    const { ReferencedSOPInstanceUID, imageId, frameNumber } = measurement;\n\n    if (!sopInstanceUIDToImageId[ReferencedSOPInstanceUID]) {\n      sopInstanceUIDToImageId[ReferencedSOPInstanceUID] = imageId;\n      imageIdsForToolState[ReferencedSOPInstanceUID] = [];\n    }\n    if (!imageIdsForToolState[ReferencedSOPInstanceUID][frameNumber]) {\n      imageIdsForToolState[ReferencedSOPInstanceUID][frameNumber] = imageId;\n    }\n  });\n\n  // Mapping of legacy datasets is now directly handled by adapters module\n  const datasetToUse = instance;\n\n  // Use CS3D adapters to generate toolState.\n  let storedMeasurementByAnnotationType = MeasurementReport.generateToolState(\n    datasetToUse,\n    // NOTE: we need to pass in the imageIds to dcmjs since the we use them\n    // for the imageToWorld transformation. The following assumes that the order\n    // that measurements were added to the display set are the same order as\n    // the measurementGroups in the instance.\n    sopInstanceUIDToImageId,\n    metaData\n  );\n\n  const onBeforeSRHydration = customizationService.getCustomization('onBeforeSRHydration')?.value;\n\n  if (typeof onBeforeSRHydration === 'function') {\n    storedMeasurementByAnnotationType = onBeforeSRHydration({\n      storedMeasurementByAnnotationType,\n      displaySet,\n    });\n  }\n\n  // Filter what is found by DICOM SR to measurements we support.\n  const mappingDefinitions = mappings.map(m => m.annotationType);\n  const hydratableMeasurementsInSR = {};\n\n  Object.keys(storedMeasurementByAnnotationType).forEach(key => {\n    if (mappingDefinitions.includes(key)) {\n      hydratableMeasurementsInSR[key] = storedMeasurementByAnnotationType[key];\n    }\n  });\n\n  // Set the series touched as tracked.\n  const imageIds = [];\n\n  // TODO: notification if no hydratable?\n  Object.keys(hydratableMeasurementsInSR).forEach(annotationType => {\n    const toolDataForAnnotationType = hydratableMeasurementsInSR[annotationType];\n\n    toolDataForAnnotationType.forEach(toolData => {\n      // Add the measurement to toolState\n      // dcmjs and Cornerstone3D has structural defect in supporting multi-frame\n      // files, and looking up the imageId from sopInstanceUIDToImageId results\n      // in the wrong value.\n      const frameNumber = (toolData.annotation.data && toolData.annotation.data.frameNumber) || 1;\n      const imageId =\n        imageIdsForToolState[toolData.sopInstanceUid][frameNumber] ||\n        sopInstanceUIDToImageId[toolData.sopInstanceUid];\n\n      if (!imageIds.includes(imageId)) {\n        imageIds.push(imageId);\n      }\n    });\n  });\n\n  let targetStudyInstanceUID;\n  const SeriesInstanceUIDs = [];\n\n  for (let i = 0; i < imageIds.length; i++) {\n    const imageId = imageIds[i];\n    if (!imageId) {\n      continue;\n    }\n    const { SeriesInstanceUID, StudyInstanceUID } = metaData.get('instance', imageId);\n\n    if (!SeriesInstanceUIDs.includes(SeriesInstanceUID)) {\n      SeriesInstanceUIDs.push(SeriesInstanceUID);\n    }\n\n    if (!targetStudyInstanceUID) {\n      targetStudyInstanceUID = StudyInstanceUID;\n    } else if (targetStudyInstanceUID !== StudyInstanceUID) {\n      console.warn('NO SUPPORT FOR SRs THAT HAVE MEASUREMENTS FROM MULTIPLE STUDIES.');\n    }\n  }\n\n  /**\n   * Gets reference data for what frame of reference and the referenced\n   * image id, or for 3d measurements, the volumeId to apply this annotation to.\n   */\n  function getReferenceData(toolData): ToolTypes.AnnotationMetadata {\n    // Add the measurement to toolState\n    // dcmjs and Cornerstone3D has structural defect in supporting multi-frame\n    // files, and looking up the imageId from sopInstanceUIDToImageId results\n    // in the wrong value.\n    const frameNumber = (toolData.annotation.data && toolData.annotation.data.frameNumber) || 1;\n    const imageId =\n      imageIdsForToolState[toolData.sopInstanceUid][frameNumber] ||\n      sopInstanceUIDToImageId[toolData.sopInstanceUid];\n\n    if (!imageId) {\n      return getReferenceData3D(toolData, servicesManager);\n    }\n\n    const instance = metaData.get('instance', imageId);\n    const {\n      FrameOfReferenceUID,\n      // SOPInstanceUID,\n      // SeriesInstanceUID,\n      // StudyInstanceUID,\n    } = instance;\n\n    return {\n      referencedImageId: imageId,\n      FrameOfReferenceUID,\n    };\n  }\n\n  Object.keys(hydratableMeasurementsInSR).forEach(annotationType => {\n    const toolDataForAnnotationType = hydratableMeasurementsInSR[annotationType];\n\n    toolDataForAnnotationType.forEach(toolData => {\n      toolData.uid = guid();\n      const referenceData = getReferenceData(toolData);\n      const { imageId } = referenceData;\n\n      const annotation = {\n        annotationUID: toolData.annotation.annotationUID,\n        data: toolData.annotation.data,\n        metadata: {\n          ...referenceData,\n          toolName: annotationType,\n        },\n      };\n      utilities.updatePlaneRestriction(annotation.data.handles.points, annotation.metadata);\n\n      const source = measurementService.getSource(\n        CORNERSTONE_3D_TOOLS_SOURCE_NAME,\n        CORNERSTONE_3D_TOOLS_SOURCE_VERSION\n      );\n      annotation.data.label = getLabelFromDCMJSImportedToolData(toolData);\n      annotation.data.finding = convertCode(codingValues, toolData.finding?.[0]);\n      annotation.data.findingSites = convertSites(codingValues, toolData.findingSites);\n      annotation.data.findingSites?.forEach(site => {\n        if (site.type) {\n          annotation.data[site.type] = site;\n        }\n      });\n\n      const matchingMapping = mappings.find(m => m.annotationType === annotationType);\n\n      const newAnnotationUID = measurementService.addRawMeasurement(\n        source,\n        annotationType,\n        { annotation },\n        matchingMapping.toMeasurementSchema,\n        dataSource\n      );\n\n      commandsManager.runCommand('updateMeasurement', {\n        uid: newAnnotationUID,\n        code: annotation.data.finding,\n      });\n\n      if (disableEditing) {\n        locking.setAnnotationLocked(newAnnotationUID, true);\n      }\n\n      if (imageId && !imageIds.includes(imageId)) {\n        imageIds.push(imageId);\n      }\n    });\n  });\n\n  displaySet.isHydrated = true;\n\n  return {\n    StudyInstanceUID: targetStudyInstanceUID,\n    SeriesInstanceUIDs,\n  };\n}\n\n/**\n * For 3d annotations, there are often several display sets which could\n * be used to display the annotation.  Choose the first annotation with the\n * same frame of reference that is reconstructable, or the first display set\n * otherwise.\n */\nfunction chooseDisplaySet(displaySets, annotation) {\n  if (!displaySets?.length) {\n    console.warn('No display set found for', annotation);\n    return;\n  }\n  if (displaySets.length === 1) {\n    return displaySets[0];\n  }\n  const volumeDs = displaySets.find(ds => ds.isReconstructable);\n  if (volumeDs) {\n    return volumeDs;\n  }\n  return displaySets[0];\n}\n\n/**\n * Gets the additional reference data appropriate for a 3d reference.\n * This will choose a volume id, frame of reference and a plane restriction.\n */\nfunction getReferenceData3D(toolData, servicesManager: Types.ServicesManager) {\n  const { FrameOfReferenceUID } = toolData.annotation.metadata;\n  const { points } = toolData.annotation.data.handles;\n  const { displaySetService } = servicesManager.services;\n  const displaySetsFOR = displaySetService.getDisplaySetsBy(\n    ds => ds.FrameOfReferenceUID === FrameOfReferenceUID\n  );\n  if (!displaySetsFOR.length || !points?.length) {\n    return {\n      FrameOfReferenceUID,\n    };\n  }\n  const ds = chooseDisplaySet(displaySetsFOR, toolData.annotation);\n  const cameraView = chooseCameraView(ds, points);\n\n  const viewReference = {\n    ...cameraView,\n    volumeId: ds.displaySetInstanceUID,\n    FrameOfReferenceUID,\n  };\n  utilities.updatePlaneRestriction(points, viewReference);\n  return viewReference;\n}\n\n/**\n * Chooses a possible camera view - right now this is fairly basic,\n * just setting the unknowns to null.\n */\nfunction chooseCameraView(_ds, points) {\n  const selectedPoints = choosePoints(points);\n  const cameraFocalPoint = <Point3>centerOf(selectedPoints);\n  // These are sufficient to be null for now and can be set on first view\n  let viewPlaneNormal: Types.Point3 = null;\n  let viewUp: Types.Point3 = null;\n\n  return {\n    cameraFocalPoint,\n    viewPlaneNormal,\n    viewUp,\n  };\n}\n\nfunction centerOf(points) {\n  const scale = 1 / points.length;\n  const center = vec3.create();\n  for (const point of points) {\n    vec3.scaleAndAdd(center, center, point, scale);\n  }\n  return center;\n}\n\nfunction choosePoints(points) {\n  if (points.length === 1 || points.length === 2) {\n    return points;\n  }\n  const firstIndex = 0;\n  const secondIndex = Math.ceil(points.length / 4);\n  const thirdIndex = Math.ceil(points.length / 2);\n  // TODO - check if colinear, if so try to find another 3 points.\n\n  const newPoints = [points[firstIndex], points[secondIndex], points[thirdIndex]];\n  return newPoints;\n}\n","import { metaData, utilities } from '@cornerstonejs/core';\n\nimport OHIF, { DicomMetadataStore } from '@ohif/core';\nimport dcmjs from 'dcmjs';\nimport { adaptersSR } from '@cornerstonejs/adapters';\n\nimport getFilteredCornerstoneToolState from './utils/getFilteredCornerstoneToolState';\nimport hydrateStructuredReport from './utils/hydrateStructuredReport';\n\nconst { MeasurementReport } = adaptersSR.Cornerstone3D;\nconst { log } = OHIF;\n\ninterface Options {\n  SeriesDescription?: string;\n  SeriesInstanceUID?: string;\n  SeriesNumber?: number;\n  InstanceNumber?: number;\n  SeriesDate?: string;\n  SeriesTime?: string;\n}\n\n/**\n * @param measurementData An array of measurements from the measurements service\n * that you wish to serialize.\n * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\n * @param options Naturalized DICOM JSON headers to merge into the displaySet.\n *\n */\nconst _generateReport = (measurementData, additionalFindingTypes, options: Options = {}) => {\n  const filteredToolState = getFilteredCornerstoneToolState(\n    measurementData,\n    additionalFindingTypes\n  );\n\n  const report = MeasurementReport.generateReport(filteredToolState, metaData, options);\n\n  const { dataset } = report;\n\n  // Set the default character set as UTF-8\n  // https://dicom.innolitics.com/ciods/nm-image/sop-common/00080005\n  if (typeof dataset.SpecificCharacterSet === 'undefined') {\n    dataset.SpecificCharacterSet = 'ISO_IR 192';\n  }\n\n  dataset.InstanceNumber = options.InstanceNumber ?? 1;\n\n  return dataset;\n};\n\nconst commandsModule = (props: withAppTypes) => {\n  const { servicesManager, extensionManager, commandsManager } = props;\n  const { customizationService } = servicesManager.services;\n\n  const actions = {\n    changeColorMeasurement: ({ uid }) => {\n      // When this gets supported, it probably belongs in cornerstone, not sr\n      throw new Error('Unsupported operation: changeColorMeasurement');\n      // const { color } = measurementService.getMeasurement(uid);\n      // const rgbaColor = {\n      //   r: color[0],\n      //   g: color[1],\n      //   b: color[2],\n      //   a: color[3] / 255.0,\n      // };\n      // colorPickerDialog(uiDialogService, rgbaColor, (newRgbaColor, actionId) => {\n      //   if (actionId === 'cancel') {\n      //     return;\n      //   }\n\n      //   const color = [newRgbaColor.r, newRgbaColor.g, newRgbaColor.b, newRgbaColor.a * 255.0];\n      // segmentationService.setSegmentColor(viewportId, segmentationId, segmentIndex, color);\n      // });\n    },\n\n    /**\n     *\n     * @param measurementData An array of measurements from the measurements service\n     * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\n     * @param options Naturalized DICOM JSON headers to merge into the displaySet.\n     * as opposed to Finding Sites.\n     * that you wish to serialize.\n     */\n    downloadReport: ({ measurementData, additionalFindingTypes, options = {} }) => {\n      const srDataset = _generateReport(measurementData, additionalFindingTypes, options);\n      const reportBlob = dcmjs.data.datasetToBlob(srDataset);\n\n      //Create a URL for the binary.\n      const objectUrl = URL.createObjectURL(reportBlob);\n      window.location.assign(objectUrl);\n    },\n\n    /**\n     *\n     * @param measurementData An array of measurements from the measurements service\n     * that you wish to serialize.\n     * @param dataSource The dataSource that you wish to use to persist the data.\n     * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\n     * @param options Naturalized DICOM JSON headers to merge into the displaySet.\n     * @return The naturalized report\n     */\n    storeMeasurements: async ({\n      measurementData,\n      dataSource,\n      additionalFindingTypes,\n      options = {},\n    }) => {\n      // Use the @cornerstonejs adapter for converting to/from DICOM\n      // But it is good enough for now whilst we only have cornerstone as a datasource.\n      log.info('[DICOMSR] storeMeasurements');\n\n      if (!dataSource || !dataSource.store || !dataSource.store.dicom) {\n        log.error('[DICOMSR] datasource has no dataSource.store.dicom endpoint!');\n        return Promise.reject({});\n      }\n\n      try {\n        const naturalizedReport = _generateReport(measurementData, additionalFindingTypes, options);\n\n        const { StudyInstanceUID, ContentSequence } = naturalizedReport;\n        // The content sequence has 5 or more elements, of which\n        // the `[4]` element contains the annotation data, so this is\n        // checking that there is some annotation data present.\n        if (!ContentSequence?.[4].ContentSequence?.length) {\n          console.log('naturalizedReport missing imaging content', naturalizedReport);\n          throw new Error('Invalid report, no content');\n        }\n        if (!naturalizedReport.SOPClassUID) {\n          throw new Error('No sop class uid');\n        }\n\n        const onBeforeDicomStore = customizationService.getCustomization('onBeforeDicomStore');\n\n        let dicomDict;\n        if (typeof onBeforeDicomStore === 'function') {\n          dicomDict = onBeforeDicomStore({ dicomDict, measurementData, naturalizedReport });\n        }\n\n        await dataSource.store.dicom(naturalizedReport, null, dicomDict);\n\n        if (StudyInstanceUID) {\n          dataSource.deleteStudyMetadataPromise(StudyInstanceUID);\n        }\n\n        // The \"Mode\" route listens for DicomMetadataStore changes\n        // When a new instance is added, it listens and\n        // automatically calls makeDisplaySets\n        DicomMetadataStore.addInstances([naturalizedReport], true);\n\n        return naturalizedReport;\n      } catch (error) {\n        console.warn(error);\n        log.error(`[DICOMSR] Error while saving the measurements: ${error.message}`);\n        throw new Error(error.message || 'Error while saving the measurements.');\n      }\n    },\n\n    /**\n     * Loads measurements by hydrating and loading the SR for the given display set instance UID\n     * and displays it in the active viewport.\n     */\n    hydrateStructuredReport: ({ displaySetInstanceUID }) => {\n      return hydrateStructuredReport(\n        { servicesManager, extensionManager, commandsManager },\n        displaySetInstanceUID\n      );\n    },\n  };\n\n  const definitions = {\n    downloadReport: actions.downloadReport,\n    storeMeasurements: actions.storeMeasurements,\n    hydrateStructuredReport: actions.hydrateStructuredReport,\n  };\n\n  return {\n    actions,\n    definitions,\n    defaultContext: 'CORNERSTONE_STRUCTURED_REPORT',\n  };\n};\n\nexport default commandsModule;\n","import { Types, metaData, utilities as csUtils } from '@cornerstonejs/core';\nimport {\n  AnnotationTool,\n  annotation,\n  drawing,\n  utilities,\n  Types as cs3DToolsTypes,\n} from '@cornerstonejs/tools';\nimport { getTrackingUniqueIdentifiersForElement } from './modules/dicomSRModule';\nimport { SCOORDTypes } from '../enums';\nimport toolNames from './toolNames';\n\nexport default class DICOMSRDisplayTool extends AnnotationTool {\n  static toolName = toolNames.DICOMSRDisplay;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      configuration: {},\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _getTextBoxLinesFromLabels(labels) {\n    // TODO -> max 5 for now (label + shortAxis + longAxis), need a generic solution for this!\n\n    const labelLength = Math.min(labels.length, 5);\n    const lines = [];\n\n    for (let i = 0; i < labelLength; i++) {\n      const labelEntry = labels[i];\n      lines.push(`${_labelToShorthand(labelEntry.label)}: ${labelEntry.value}`);\n    }\n\n    return lines;\n  }\n\n  // This tool should not inherit from AnnotationTool and we should not need\n  // to add the following lines.\n  isPointNearTool = () => null;\n  getHandleNearImagePoint = () => null;\n\n  renderAnnotation = (enabledElement: Types.IEnabledElement, svgDrawingHelper: any): void => {\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = annotation.state.getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const trackingUniqueIdentifiersForElement = getTrackingUniqueIdentifiersForElement(element);\n\n    const { activeIndex, trackingUniqueIdentifiers } = trackingUniqueIdentifiersForElement;\n\n    const activeTrackingUniqueIdentifier = trackingUniqueIdentifiers[activeIndex];\n\n    // Filter toolData to only render the data for the active SR.\n    const filteredAnnotations = annotations.filter(annotation =>\n      trackingUniqueIdentifiers.includes(annotation.data?.TrackingUniqueIdentifier)\n    );\n\n    if (!viewport._actors?.size) {\n      return;\n    }\n\n    const styleSpecifier: cs3DToolsTypes.AnnotationStyle.StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n    const { style: annotationStyle } = annotation.config;\n\n    for (let i = 0; i < filteredAnnotations.length; i++) {\n      const annotation = filteredAnnotations[i];\n      const annotationUID = annotation.annotationUID;\n      const { renderableData, TrackingUniqueIdentifier } = annotation.data;\n      const { referencedImageId } = annotation.metadata;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const groupStyle = annotationStyle.getToolGroupToolStyles(this.toolGroupId)[\n        this.getToolName()\n      ];\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color =\n        TrackingUniqueIdentifier === activeTrackingUniqueIdentifier\n          ? 'rgb(0, 255, 0)'\n          : this.getStyle('color', styleSpecifier, annotation);\n\n      const options = {\n        color,\n        lineDash,\n        lineWidth,\n        ...groupStyle,\n      };\n\n      Object.keys(renderableData).forEach(GraphicType => {\n        const renderableDataForGraphicType = renderableData[GraphicType];\n\n        let renderMethod;\n        let canvasCoordinatesAdapter;\n\n        switch (GraphicType) {\n          case SCOORDTypes.POINT:\n            renderMethod = this.renderPoint;\n            break;\n          case SCOORDTypes.MULTIPOINT:\n            renderMethod = this.renderMultipoint;\n            break;\n          case SCOORDTypes.POLYLINE:\n            renderMethod = this.renderPolyLine;\n            break;\n          case SCOORDTypes.CIRCLE:\n            renderMethod = this.renderEllipse;\n            break;\n          case SCOORDTypes.ELLIPSE:\n            renderMethod = this.renderEllipse;\n            canvasCoordinatesAdapter = utilities.math.ellipse.getCanvasEllipseCorners;\n            break;\n          default:\n            throw new Error(`Unsupported GraphicType: ${GraphicType}`);\n        }\n\n        const canvasCoordinates = renderMethod(\n          svgDrawingHelper,\n          viewport,\n          renderableDataForGraphicType,\n          annotationUID,\n          referencedImageId,\n          options\n        );\n\n        this.renderTextBox(\n          svgDrawingHelper,\n          viewport,\n          canvasCoordinates,\n          canvasCoordinatesAdapter,\n          annotation,\n          styleSpecifier,\n          options\n        );\n      });\n    }\n  };\n\n  renderPolyLine(\n    svgDrawingHelper,\n    viewport,\n    renderableData,\n    annotationUID,\n    referencedImageId,\n    options\n  ) {\n    const drawingOptions = {\n      color: options.color,\n      width: options.lineWidth,\n      lineDash: options.lineDash,\n    };\n    let allCanvasCoordinates = [];\n    renderableData.map((data, index) => {\n      const canvasCoordinates = data.map(p => viewport.worldToCanvas(p));\n      const lineUID = `${index}`;\n\n      if (canvasCoordinates.length === 2) {\n        drawing.drawLine(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n          drawingOptions\n        );\n      } else {\n        drawing.drawPolyline(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates,\n          drawingOptions\n        );\n      }\n\n      allCanvasCoordinates = allCanvasCoordinates.concat(canvasCoordinates);\n    });\n\n    return allCanvasCoordinates; // used for drawing textBox\n  }\n\n  renderMultipoint(\n    svgDrawingHelper,\n    viewport,\n    renderableData,\n    annotationUID,\n    referencedImageId,\n    options\n  ) {\n    let canvasCoordinates;\n    renderableData.map((data, index) => {\n      canvasCoordinates = data.map(p => viewport.worldToCanvas(p));\n      const handleGroupUID = '0';\n      drawing.drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n        color: options.color,\n      });\n    });\n  }\n\n  renderPoint(\n    svgDrawingHelper,\n    viewport,\n    renderableData,\n    annotationUID,\n    referencedImageId,\n    options\n  ) {\n    const canvasCoordinates = [];\n    renderableData.map((data, index) => {\n      const point = data[0];\n      // This gives us one point for arrow\n      canvasCoordinates.push(viewport.worldToCanvas(point));\n\n      if (data[1] !== undefined) {\n        canvasCoordinates.push(viewport.worldToCanvas(data[1]));\n      }\n      else{\n         // We get the other point for the arrow by using the image size\n      const imagePixelModule = metaData.get('imagePixelModule', referencedImageId);\n\n      let xOffset = 10;\n      let yOffset = 10;\n\n      if (imagePixelModule) {\n        const { columns, rows } = imagePixelModule;\n        xOffset = columns / 10;\n        yOffset = rows / 10;\n      }\n\n      const imagePoint = csUtils.worldToImageCoords(referencedImageId, point);\n      const arrowEnd = csUtils.imageToWorldCoords(referencedImageId, [\n        imagePoint[0] + xOffset,\n        imagePoint[1] + yOffset,\n      ]);\n\n      canvasCoordinates.push(viewport.worldToCanvas(arrowEnd));\n        \n      }\n     \n\n      const arrowUID = `${index}`;\n\n      // Todo: handle drawing probe as probe, currently we are drawing it as an arrow\n      drawing.drawArrow(\n        svgDrawingHelper,\n        annotationUID,\n        arrowUID,\n        canvasCoordinates[1],\n        canvasCoordinates[0],\n        {\n          color: options.color,\n          width: options.lineWidth,\n        }\n      );\n    });\n\n    return canvasCoordinates; // used for drawing textBox\n  }\n\n  renderEllipse(\n    svgDrawingHelper,\n    viewport,\n    renderableData,\n    annotationUID,\n    referencedImageId,\n    options\n  ) {\n    let canvasCoordinates;\n    renderableData.map((data, index) => {\n      if (data.length === 0) {\n        // since oblique ellipse is not supported for hydration right now\n        // we just return\n        return;\n      }\n\n      const ellipsePointsWorld = data;\n\n      const rotation = viewport.getRotation();\n\n      canvasCoordinates = ellipsePointsWorld.map(p => viewport.worldToCanvas(p));\n      let canvasCorners;\n      if (rotation == 90 || rotation == 270) {\n        canvasCorners = utilities.math.ellipse.getCanvasEllipseCorners([\n          canvasCoordinates[2],\n          canvasCoordinates[3],\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n        ]) as Array<Types.Point2>;\n      } else {\n        canvasCorners = utilities.math.ellipse.getCanvasEllipseCorners(\n          canvasCoordinates\n        ) as Array<Types.Point2>;\n      }\n\n      const lineUID = `${index}`;\n      drawing.drawEllipse(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCorners[0],\n        canvasCorners[1],\n        {\n          color: options.color,\n          width: options.lineWidth,\n          lineDash: options.lineDash,\n        }\n      );\n    });\n\n    return canvasCoordinates;\n  }\n\n  renderTextBox(\n    svgDrawingHelper,\n    viewport,\n    canvasCoordinates,\n    canvasCoordinatesAdapter,\n    annotation,\n    styleSpecifier,\n    options = {}\n  ) {\n    if (!canvasCoordinates || !annotation) {\n      return;\n    }\n\n    const { annotationUID, data = {} } = annotation;\n    const { labels } = data;\n    const { color } = options;\n\n    let adaptedCanvasCoordinates = canvasCoordinates;\n    // adapt coordinates if there is an adapter\n    if (typeof canvasCoordinatesAdapter === 'function') {\n      adaptedCanvasCoordinates = canvasCoordinatesAdapter(canvasCoordinates);\n    }\n    const textLines = this._getTextBoxLinesFromLabels(labels);\n    const canvasTextBoxCoords = utilities.drawing.getTextBoxCoordsCanvas(adaptedCanvasCoordinates);\n\n    if (!annotation.data?.handles?.textBox?.worldPosition) {\n      annotation.data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(annotation.data.handles.textBox.worldPosition);\n\n    const textBoxUID = '1';\n    const textBoxOptions = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n\n    const boundingBox = drawing.drawLinkedTextBox(\n      svgDrawingHelper,\n      annotationUID,\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      {\n        ...textBoxOptions,\n        color,\n      }\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    annotation.data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  }\n}\n\nconst SHORT_HAND_MAP = {\n  'Short Axis': 'W: ',\n  'Long Axis': 'L: ',\n  AREA: 'Area: ',\n  Length: '',\n  CORNERSTONEFREETEXT: '',\n};\n\nfunction _labelToShorthand(label) {\n  const shortHand = SHORT_HAND_MAP[label];\n\n  if (shortHand !== undefined) {\n    return shortHand;\n  }\n\n  return label;\n}\n","import { type Types } from '@cornerstonejs/core';\nimport {\n  annotation,\n  drawing,\n  utilities,\n  Types as cs3DToolsTypes,\n  AnnotationDisplayTool,\n} from '@cornerstonejs/tools';\nimport toolNames from './toolNames';\nimport { Annotation } from '@cornerstonejs/tools/dist/types/types';\n\nexport default class SCOORD3DPointTool extends AnnotationDisplayTool {\n  static toolName = toolNames.SRSCOORD3DPoint;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      configuration: {},\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _getTextBoxLinesFromLabels(labels) {\n    // TODO -> max 5 for now (label + shortAxis + longAxis), need a generic solution for this!\n\n    const labelLength = Math.min(labels.length, 5);\n    const lines = [];\n\n    return lines;\n  }\n\n  // This tool should not inherit from AnnotationTool and we should not need\n  // to add the following lines.\n  isPointNearTool = () => null;\n  getHandleNearImagePoint = () => null;\n\n  renderAnnotation = (enabledElement: Types.IEnabledElement, svgDrawingHelper: any): void => {\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    const annotations = annotation.state.getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return;\n    }\n\n    // Filter toolData to only render the data for the active SR.\n    const filteredAnnotations = annotations;\n    if (!viewport._actors?.size) {\n      return;\n    }\n\n    const styleSpecifier: cs3DToolsTypes.AnnotationStyle.StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < filteredAnnotations.length; i++) {\n      const annotation = filteredAnnotations[i];\n\n      const annotationUID = annotation.annotationUID;\n      const { renderableData } = annotation.data;\n      const { POINT: points } = renderableData;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const options = {\n        color,\n        lineDash,\n        lineWidth,\n      };\n\n      const point = points[0][0];\n\n      // check if viewport can render it\n      const viewable = viewport.isReferenceViewable(\n        { FrameOfReferenceUID: annotation.metadata.FrameOfReferenceUID, cameraFocalPoint: point },\n        { asNearbyProjection: true }\n      );\n\n      if (!viewable) {\n        continue;\n      }\n\n      // render the point\n      const arrowPointCanvas = viewport.worldToCanvas(point);\n      // Todo: configure this\n      const arrowEndCanvas = [arrowPointCanvas[0] + 20, arrowPointCanvas[1] + 20];\n      const canvasCoordinates = [arrowPointCanvas, arrowEndCanvas];\n\n      drawing.drawArrow(\n        svgDrawingHelper,\n        annotationUID,\n        '1',\n        canvasCoordinates[1],\n        canvasCoordinates[0],\n        {\n          color: options.color,\n          width: options.lineWidth,\n        }\n      );\n\n      this.renderTextBox(\n        svgDrawingHelper,\n        viewport,\n        canvasCoordinates,\n        annotation,\n        styleSpecifier,\n        options\n      );\n    }\n  };\n\n  renderTextBox(\n    svgDrawingHelper,\n    viewport,\n    canvasCoordinates,\n    annotation,\n    styleSpecifier,\n    options = {}\n  ) {\n    if (!canvasCoordinates || !annotation) {\n      return;\n    }\n\n    const { annotationUID, data = {} } = annotation;\n    const { labels } = data;\n\n    const textLines = [];\n\n    for (const label of labels) {\n      // make this generic\n      // fix this\n      if (label.label === '363698007') {\n        textLines.push(`Finding Site: ${label.value}`);\n      }\n    }\n\n    const { color } = options;\n\n    const adaptedCanvasCoordinates = canvasCoordinates;\n    // adapt coordinates if there is an adapter\n    const canvasTextBoxCoords = utilities.drawing.getTextBoxCoordsCanvas(adaptedCanvasCoordinates);\n\n    if (!annotation.data?.handles?.textBox?.worldPosition) {\n      annotation.data.handles.textBox.worldPosition = viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(annotation.data.handles.textBox.worldPosition);\n\n    const textBoxUID = '1';\n    const textBoxOptions = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n\n    const boundingBox = drawing.drawLinkedTextBox(\n      svgDrawingHelper,\n      annotationUID,\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      {\n        ...textBoxOptions,\n        color,\n      }\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    annotation.data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  }\n\n  public getLinkedTextBoxStyle(\n    specifications: cs3DToolsTypes.AnnotationStyle.StyleSpecifier,\n    annotation?: Annotation\n  ): Record<string, unknown> {\n    // Todo: this function can be used to set different styles for different toolMode\n    // for the textBox.\n\n    return {\n      visibility: this.getStyle('textBoxVisibility', specifications, annotation),\n      fontFamily: this.getStyle('textBoxFontFamily', specifications, annotation),\n      fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n      color: this.getStyle('textBoxColor', specifications, annotation),\n      shadow: this.getStyle('textBoxShadow', specifications, annotation),\n      background: this.getStyle('textBoxBackground', specifications, annotation),\n      lineWidth: this.getStyle('textBoxLinkLineWidth', specifications, annotation),\n      lineDash: this.getStyle('textBoxLinkLineDash', specifications, annotation),\n    };\n  }\n}\n","const SRSCOOR3DProbe = {\n  toAnnotation: measurement => {},\n\n  /**\n   * Maps cornerstone annotation event data to measurement service format.\n   *\n   * @param {Object} cornerstone Cornerstone event data\n   * @return {Measurement} Measurement instance\n   */\n  toMeasurement: ({ servicesManager, getValueTypeFromToolType }, csToolsEventDetail) => {\n    const { displaySetService } = servicesManager.services;\n    const { annotation } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Probe tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, FrameOfReferenceUID } = metadata;\n    const { points } = data.handles;\n\n    const displaySets = displaySetService\n      .getActiveDisplaySets()\n      .filter(ds => ds.FrameOfReferenceUID === FrameOfReferenceUID);\n    const displaySet = displaySets.filter(ds => ds.isReconstructable)[0] || displaySets[0];\n\n    const { StudyInstanceUID: referenceStudyUID, SeriesInstanceUID: referenceSeriesUID } =\n      displaySets[0] || {};\n\n    const displayText = getDisplayText(annotation);\n    return {\n      uid: annotationUID,\n      points,\n      metadata,\n      referenceStudyUID,\n      referenceSeriesUID,\n      displaySetInstanceUID: displaySet?.displaySetInstanceUID,\n      toolName: metadata.toolName,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType?.(toolName) ?? null,\n    };\n  },\n};\n\nfunction getDisplayText(annotation) {\n  const { data } = annotation;\n\n  if (!data) {\n    return [''];\n  }\n  const { labels } = data;\n\n  const displayText = [];\n\n  for (const label of labels) {\n    // make this generic\n    if (label.label === '33636980076') {\n      displayText.push(`Finding Site: ${label.value}`);\n    }\n  }\n\n  return {\n    primary: displayText,\n    secondary: [],\n  };\n}\n\nexport default SRSCOOR3DProbe;\n","import { addTool } from '@cornerstonejs/tools';\n\nexport default function addToolInstance(name: string, toolClass, configuration = {}): void {\n  class InstanceClass extends toolClass {\n    static toolName = name;\n    constructor(toolProps, defaultToolProps) {\n      toolProps.configuration = toolProps.configuration\n        ? { ...toolProps.configuration, ...configuration }\n        : configuration;\n      super(toolProps, defaultToolProps);\n    }\n  }\n  addTool(InstanceClass);\n}\n","import {\n  AngleTool,\n  annotation,\n  ArrowAnnotateTool,\n  BidirectionalTool,\n  CobbAngleTool,\n  EllipticalROITool,\n  CircleROITool,\n  LengthTool,\n  PlanarFreehandROITool,\n  RectangleROITool,\n  utilities as csToolsUtils,\n} from '@cornerstonejs/tools';\nimport { Types, MeasurementService } from '@ohif/core';\nimport { Enums as CSExtensionEnums } from '@ohif/extension-cornerstone';\nimport DICOMSRDisplayTool from './tools/DICOMSRDisplayTool';\nimport SCOORD3DPointTool from './tools/SCOORD3DPointTool';\nimport SRSCOOR3DProbeMapper from './utils/SRSCOOR3DProbeMapper';\nimport addToolInstance from './utils/addToolInstance';\nimport toolNames from './tools/toolNames';\n\nconst { CORNERSTONE_3D_TOOLS_SOURCE_NAME, CORNERSTONE_3D_TOOLS_SOURCE_VERSION } = CSExtensionEnums;\n\n/**\n * @param {object} configuration\n */\nexport default function init({\n  configuration = {},\n  servicesManager,\n}: Types.Extensions.ExtensionParams): void {\n  const { measurementService, cornerstoneViewportService } = servicesManager.services;\n\n  addToolInstance(toolNames.DICOMSRDisplay, DICOMSRDisplayTool);\n  addToolInstance(toolNames.SRLength, LengthTool);\n  addToolInstance(toolNames.SRBidirectional, BidirectionalTool);\n  addToolInstance(toolNames.SREllipticalROI, EllipticalROITool);\n  addToolInstance(toolNames.SRCircleROI, CircleROITool);\n  addToolInstance(toolNames.SRArrowAnnotate, ArrowAnnotateTool);\n  addToolInstance(toolNames.SRAngle, AngleTool);\n  addToolInstance(toolNames.SRPlanarFreehandROI, PlanarFreehandROITool);\n  addToolInstance(toolNames.SRRectangleROI, RectangleROITool);\n  addToolInstance(toolNames.SRSCOORD3DPoint, SCOORD3DPointTool);\n\n  // TODO - fix the SR display of Cobb Angle, as it joins the two lines\n  addToolInstance(toolNames.SRCobbAngle, CobbAngleTool);\n\n  const csTools3DVer1MeasurementSource = measurementService.getSource(\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\n  );\n\n  const { POINT } = measurementService.VALUE_TYPES;\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'SRSCOORD3DPoint',\n    POINT,\n    SRSCOOR3DProbeMapper.toAnnotation,\n    SRSCOOR3DProbeMapper.toMeasurement.bind(null, { servicesManager })\n  );\n\n  // Modify annotation tools to use dashed lines on SR\n  const dashedLine = {\n    lineDash: '4,4',\n  };\n  annotation.config.style.setToolGroupToolStyles('SRToolGroup', {\n    [toolNames.DICOMSRDisplay]: dashedLine,\n    SRLength: dashedLine,\n    SRBidirectional: dashedLine,\n    SREllipticalROI: dashedLine,\n    SRCircleROI: dashedLine,\n    SRArrowAnnotate: dashedLine,\n    SRCobbAngle: dashedLine,\n    SRAngle: dashedLine,\n    SRPlanarFreehandROI: dashedLine,\n    SRRectangleROI: dashedLine,\n    global: {},\n  });\n}\n","import React from 'react';\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\nimport { srProtocol } from './getHangingProtocolModule';\nimport onModeEnter from './onModeEnter';\nimport getCommandsModule from './commandsModule';\nimport preRegistration from './init';\nimport { id } from './id.js';\nimport toolNames from './tools/toolNames';\nimport hydrateStructuredReport from './utils/hydrateStructuredReport';\nimport createReferencedImageDisplaySet from './utils/createReferencedImageDisplaySet';\nimport Enums from './enums';\n\nconst Component = React.lazy(() => {\n  return import(/* webpackPrefetch: true */ './components/OHIFCornerstoneSRViewport');\n});\n\nconst OHIFCornerstoneSRViewport = props => {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <Component {...props} />\n    </React.Suspense>\n  );\n};\n\n/**\n *\n */\nconst dicomSRExtension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   */\n  id,\n\n  onModeEnter,\n\n  preRegistration,\n\n  /**\n   *\n   *\n   * @param {object} [configuration={}]\n   * @param {object|array} [configuration.csToolsConfig] - Passed directly to `initCornerstoneTools`\n   */\n  getViewportModule({ servicesManager, extensionManager }) {\n    const ExtendedOHIFCornerstoneSRViewport = props => {\n      return (\n        <OHIFCornerstoneSRViewport\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          {...props}\n        />\n      );\n    };\n\n    return [{ name: 'dicom-sr', component: ExtendedOHIFCornerstoneSRViewport }];\n  },\n  getCommandsModule,\n  getSopClassHandlerModule,\n  // Include dynamically computed values such as toolNames not known till instantiation\n  getUtilityModule({ servicesManager }) {\n    return [\n      {\n        name: 'tools',\n        exports: {\n          toolNames,\n        },\n      },\n    ];\n  },\n};\n\nexport default dicomSRExtension;\n\n// Put static exports here so they can be type checked\nexport { hydrateStructuredReport, createReferencedImageDisplaySet, srProtocol, Enums, toolNames };\n","import { SOPClassHandlerId, SOPClassHandlerId3D } from './id';\n\nexport default function onModeEnter({ servicesManager }) {\n  const { displaySetService } = servicesManager.services;\n  const displaySetCache = displaySetService.getDisplaySetCache();\n\n  const srDisplaySets = [...displaySetCache.values()].filter(\n    ds => ds.SOPClassHandlerId === SOPClassHandlerId || ds.SOPClassHandlerId === SOPClassHandlerId3D\n  );\n\n  srDisplaySets.forEach(ds => {\n    // New mode route, allow SRs to be hydrated again\n    ds.isHydrated = false;\n  });\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\n\nconst state = {\n  TrackingUniqueIdentifier: null,\n  trackingIdentifiersByViewportId: {},\n};\n\n/**\n * This file is being used to store the per-viewport state of the SR tools,\n * Since, all the toolStates are added to the cornerstoneTools, when displaying the SRTools,\n * if there are two viewports rendering the same imageId, we don't want to show\n * the same SR annotation twice on irrelevant viewport, hence, we are storing the state\n * of the SR tools in state here, so that we can filter them later.\n */\n\nfunction setTrackingUniqueIdentifiersForElement(\n  element,\n  trackingUniqueIdentifiers,\n  activeIndex = 0\n) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  state.trackingIdentifiersByViewportId[viewport.id] = {\n    trackingUniqueIdentifiers,\n    activeIndex,\n  };\n}\n\nfunction setActiveTrackingUniqueIdentifierForElement(element, TrackingUniqueIdentifier) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const trackingIdentifiersForElement = state.trackingIdentifiersByViewportId[viewport.id];\n\n  if (trackingIdentifiersForElement) {\n    const activeIndex = trackingIdentifiersForElement.trackingUniqueIdentifiers.findIndex(\n      tuid => tuid === TrackingUniqueIdentifier\n    );\n\n    trackingIdentifiersForElement.activeIndex = activeIndex;\n  }\n}\n\nfunction getTrackingUniqueIdentifiersForElement(element) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  if (state.trackingIdentifiersByViewportId[viewport.id]) {\n    return state.trackingIdentifiersByViewportId[viewport.id];\n  }\n\n  return { trackingUniqueIdentifiers: [] };\n}\n\nexport {\n  setTrackingUniqueIdentifiersForElement,\n  setActiveTrackingUniqueIdentifierForElement,\n  getTrackingUniqueIdentifiersForElement,\n};\n","import { DisplaySetService, classes } from '@ohif/core';\n\nconst ImageSet = classes.ImageSet;\n\nconst findInstance = (measurement, displaySetService: DisplaySetService) => {\n  const { displaySetInstanceUID, ReferencedSOPInstanceUID: sopUid } = measurement;\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n  if (!referencedDisplaySet.images) {\n    return;\n  }\n  return referencedDisplaySet.images.find(it => it.SOPInstanceUID === sopUid);\n};\n\n/** Finds references to display sets inside the measurements\n * contained within the provided display set.\n * @return an array of instances referenced.\n */\nconst findReferencedInstances = (displaySetService: DisplaySetService, displaySet) => {\n  const instances = [];\n  const instanceById = {};\n  for (const measurement of displaySet.measurements) {\n    const { imageId } = measurement;\n    if (!imageId) {\n      continue;\n    }\n    if (instanceById[imageId]) {\n      continue;\n    }\n\n    const instance = findInstance(measurement, displaySetService);\n    if (!instance) {\n      console.log('Measurement', measurement, 'had no instances found');\n      continue;\n    }\n\n    instanceById[imageId] = instance;\n    instances.push(instance);\n  }\n  return instances;\n};\n\n/**\n * Creates a new display set containing a single image instance for each\n * referenced image.\n *\n * @param displaySetService\n * @param displaySet - containing measurements referencing images.\n * @returns A new (registered/active) display set containing the referenced images\n */\nconst createReferencedImageDisplaySet = (displaySetService, displaySet) => {\n  const instances = findReferencedInstances(displaySetService, displaySet);\n  // This will be a  member function of the created image set\n  const updateInstances = function () {\n    this.images.splice(\n      0,\n      this.images.length,\n      ...findReferencedInstances(displaySetService, displaySet)\n    );\n    this.numImageFrames = this.images.length;\n  };\n\n  const imageSet = new ImageSet(instances);\n  const instance = instances[0];\n\n  if (!instance) {\n    return;\n  }\n\n  imageSet.setAttributes({\n    displaySetInstanceUID: imageSet.uid, // create a local alias for the imageSet UID\n    SeriesDate: instance.SeriesDate,\n    SeriesTime: instance.SeriesTime,\n    SeriesInstanceUID: imageSet.uid,\n    StudyInstanceUID: instance.StudyInstanceUID,\n    SeriesNumber: instance.SeriesNumber || 0,\n    SOPClassUID: instance.SOPClassUID,\n    SeriesDescription: `${displaySet.SeriesDescription} KO ${displaySet.instance.SeriesNumber}`,\n    Modality: 'KO',\n    isMultiFrame: false,\n    numImageFrames: instances.length,\n    SOPClassHandlerId: `@ohif/extension-default.sopClassHandlerModule.stack`,\n    isReconstructable: false,\n    // This object is made of multiple instances from other series\n    isCompositeStack: true,\n    madeInClient: true,\n    excludeFromThumbnailBrowser: true,\n    updateInstances,\n  });\n\n  displaySetService.addDisplaySets(imageSet);\n\n  return imageSet;\n};\n\nexport default createReferencedImageDisplaySet;\n"],"names":["CodeScheme","Cornerstone3DCodeScheme","adaptersSR","Cornerstone3D","SCOORDTypes","POINT","MULTIPOINT","POLYLINE","CIRCLE","ELLIPSE","CodeNameCodeSequenceValues","ImagingMeasurementReport","ImageLibrary","ImagingMeasurements","MeasurementGroup","ImageLibraryGroup","TrackingUniqueIdentifier","TrackingIdentifier","Finding","FindingSite","FindingSiteSCT","CodingSchemeDesignators","SRT","SCT","CornerstoneCodeSchemes","CodingSchemeDesignator","RelationshipType","INFERRED_FROM","CONTAINS","EPSILON","getRenderableCoords","GraphicData","ValueType","imageId","renderableData","i","length","push","worldPos","utilities","GraphicType","pointsWorld","center","onPerimeter","radius","vec3","imagePlaneModule","metaData","Error","columnCosines","rowCosines","firstAxisStart","firstAxisEnd","secondAxisStart","secondAxisEnd","majorAxisStart","majorAxisEnd","minorAxisStart","minorAxisEnd","majorAxisVec","minorAxisVec","columnCosinesVec","projectedMajorAxisOnColVec","Math","abs","projectedMinorAxisOnColVec","absoluteOfMajorDotProduct","absoluteOfMinorDotProduct","console","warn","DICOMSRDisplay","SRLength","SRBidirectional","SREllipticalROI","SRCircleROI","SRArrowAnnotate","SRAngle","SRCobbAngle","SRRectangleROI","SRPlanarFreehandROI","SRSCOORD3DPoint","MeasurementReport","addSRAnnotation","measurement","frameNumber","toolName","toolNames","coords","reduce","acc","coordProps","getRenderableData","valueType","graphicType","graphicTypePoints","frameOfReferenceUID","planeRestriction","getAdapterForTrackingIdentifier","ReferencedFrameOfReferenceSequence","FrameOfReferenceUID","point","viewReference","referencedImageId","SRAnnotation","annotationUID","highlighted","isLocked","invalidated","metadata","data","label","labels","value","undefined","displayText","handles","textBox","points","cachedStats","annotation","addAnnotation","id","packageJson","SOPClassHandlerName","SOPClassHandlerId","SOPClassHandlerName3D","SOPClassHandlerId3D","sopClassDictionary","utils","CORNERSTONE_3D_TOOLS_SOURCE_NAME","CORNERSTONE_3D_TOOLS_SOURCE_VERSION","CSExtensionEnums","MetadataProvider","metadataProvider","classes","TEXT_ANNOTATION_POSITION","COMMENT_CODE","sopClassUids","BasicTextSR","EnhancedSR","ComprehensiveSR","Comprehensive3DSR","addInstances","instances","_displaySetService","this","sortStudyInstances","instance","isLoaded","_getDisplaySetsFromSeries","servicesManager","extensionManager","StudyInstanceUID","SeriesInstanceUID","SOPInstanceUID","SeriesDescription","SeriesNumber","SeriesDate","SeriesTime","ConceptNameCodeSequence","SOPClassUID","validateSameStudyUID","uid","forEach","it","is3DSR","isImagingMeasurementReport","CodeValue","displaySet","Modality","displaySetInstanceUID","guid","referencedImages","measurements","isDerivedDisplaySet","i18n","t","load","async","srDisplaySet","displaySetService","measurementService","services","dataSources","getDataSources","dataSource","ContentSequence","retrieveBulkData","obj","parentObj","key","prop","Array","isArray","Promise","all","map","item","retrieve","bulkDataURI","BulkDataURI","Float32Array","ImagingMeasurementReportContentSequence","find","_getSequenceAsArray","ReferencedSOPSequence","ref","ReferencedSOPClassUID","ReferencedSOPInstanceUID","_getReferencedImagesList","mergedContentSequencesByTrackingUniqueIdentifiers","MeasurementGroups","TrackingUniqueIdentifierItem","trackingUniqueIdentifier","UID","_getMergedContentSequencesByTrackingUniqueIdentifiers","filter","Object","keys","mergedContentSequence","some","group","isScoordOr3d","concept","schemeDesignator","isTextPosition","graphicItem","UIDREFContentItem","TrackingIdentifierContentItem","NUMContentItems","conceptNameItem","graphicValue","graphicDesignator","graphicCode","pointDataItem","_getCoordsFromSCOORDOrSCOORD3D","is3DMeasurement","pointLength","pointsLength","loaded","TextValue","MeasuredValueSequence","_getLabelFromMeasuredValueSequence","findingSites","ConceptCodeSequence","CodeMeaning","_processTID1410Measurement","finding","commentSites","includes","codeValues","CORNERSTONEFREETEXT","cornerstoneFreeTextFindingSite","_processNonGeometricallyDefinedMeasurement","_processMeasurement","_getMeasurements","mappings","getSourceMappings","isHydrated","isRehydratable","mappingDefinitions","Set","m","add","annotationType","adapter","adapters","getAdaptersForTypes","hydratable","has","toolType","log","activeDisplaySets","activeDisplaySet","_checkIfCanAddMeasurementsToDisplaySet","subscribe","EVENTS","DISPLAY_SETS_ADDED","displaySetsAdded","newDisplaySet","_load","_measurementBelongsToDisplaySet","customizationService","unloadedMeasurements","unsupported","imageIdMap","Map","imageIds","getImageIdsForDisplaySet","getUIDsFromImageID","set","j","onBeforeSRAddMeasurement","getCustomization","splice","referencedSOPSequence","frame","ReferencedFrameNumber","get","_measurementReferencesSOPInstanceUID","Number","coord","ReferencedFrameOfReferenceUID","NumericValue","MeasurementUnitsCodeSequence","toFixed","sequence","params","getDisplaySetsFromSeries","name","srProtocol","protocolMatchingRules","toolGroupIds","numberOfPriorsReferenced","defaultViewport","viewportOptions","viewportType","toolGroupId","allowUnmatchedView","displaySets","matchedDisplaySetsIndex","displaySetSelectors","srDisplaySetId","seriesMatchingRules","attribute","constraint","equals","stages","viewportStructure","layoutType","properties","rows","columns","viewports","measurementData","additionalFindingTypes","filteredToolState","addToFilteredToolState","NO_IMAGE_ID","imageIdSpecificToolState","measurementDataI","md","toolData","assign","uids","slice","annotationManager","getAnnotationManager","framesOfReference","getFramesOfReference","frameOfReference","frameOfReferenceAnnotations","getAnnotations","toolTypes","annotations","k","uidIndex","findIndex","locking","CsAnnotation","OHIF","convertCode","codingValues","code","text","convertSites","sites","ret","site","hydrateStructuredReport","commandsManager","getActiveDataSource","disableEditing","getDisplaySetByUID","DicomMetadataStore","getInstance","sopInstanceUIDToImageId","imageIdsForToolState","datasetToUse","storedMeasurementByAnnotationType","generateToolState","onBeforeSRHydration","hydratableMeasurementsInSR","targetStudyInstanceUID","sopInstanceUid","SeriesInstanceUIDs","getReferenceData","displaySetsFOR","getDisplaySetsBy","ds","volumeDs","isReconstructable","chooseDisplaySet","chooseCameraView","volumeId","getReferenceData3D","referenceData","source","getSource","freeTextLabel","fs","getLabelFromDCMJSImportedToolData","type","matchingMapping","newAnnotationUID","addRawMeasurement","toMeasurementSchema","runCommand","setAnnotationLocked","_ds","selectedPoints","firstIndex","secondIndex","ceil","thirdIndex","newPoints","choosePoints","cameraFocalPoint","scale","centerOf","viewPlaneNormal","viewUp","_generateReport","options","getFilteredCornerstoneToolState","report","generateReport","dataset","SpecificCharacterSet","InstanceNumber","props","actions","changeColorMeasurement","downloadReport","srDataset","reportBlob","dcmjs","datasetToBlob","objectUrl","URL","createObjectURL","window","location","storeMeasurements","info","store","dicom","error","reject","naturalizedReport","onBeforeDicomStore","dicomDict","deleteStudyMetadataPromise","message","definitions","defaultContext","DICOMSRDisplayTool","AnnotationTool","constructor","toolProps","defaultToolProps","configuration","super","isPointNearTool","getHandleNearImagePoint","renderAnnotation","enabledElement","svgDrawingHelper","viewport","element","getToolName","filterInteractableAnnotationsForElement","trackingUniqueIdentifiersForElement","getTrackingUniqueIdentifiersForElement","activeIndex","trackingUniqueIdentifiers","activeTrackingUniqueIdentifier","filteredAnnotations","_actors","size","styleSpecifier","viewportId","style","annotationStyle","groupStyle","getToolGroupToolStyles","lineWidth","getStyle","lineDash","color","renderableDataForGraphicType","renderMethod","canvasCoordinatesAdapter","renderPoint","renderMultipoint","renderPolyLine","renderEllipse","canvasCoordinates","renderTextBox","_getTextBoxLinesFromLabels","labelLength","min","lines","labelEntry","_labelToShorthand","drawingOptions","width","allCanvasCoordinates","index","p","worldToCanvas","lineUID","drawing","concat","imagePixelModule","xOffset","yOffset","imagePoint","csUtils","arrowEnd","arrowUID","ellipsePointsWorld","rotation","getRotation","canvasCorners","adaptedCanvasCoordinates","textLines","canvasTextBoxCoords","worldPosition","canvasToWorld","textBoxPosition","textBoxOptions","getLinkedTextBoxStyle","boundingBox","x","left","y","top","height","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","SHORT_HAND_MAP","AREA","Length","shortHand","SCOORD3DPointTool","AnnotationDisplayTool","isReferenceViewable","asNearbyProjection","arrowPointCanvas","specifications","visibility","fontFamily","fontSize","shadow","background","toAnnotation","toMeasurement","getValueTypeFromToolType","csToolsEventDetail","getActiveDisplaySets","referenceStudyUID","referenceSeriesUID","primary","secondary","getDisplayText","addToolInstance","toolClass","InstanceClass","addTool","Component","React","OHIFCornerstoneSRViewport","fallback","onModeEnter","getDisplaySetCache","values","preRegistration","cornerstoneViewportService","LengthTool","BidirectionalTool","EllipticalROITool","CircleROITool","ArrowAnnotateTool","AngleTool","PlanarFreehandROITool","RectangleROITool","CobbAngleTool","csTools3DVer1MeasurementSource","VALUE_TYPES","addMapping","SRSCOOR3DProbeMapper","bind","dashedLine","setToolGroupToolStyles","global","getViewportModule","component","_extends","getCommandsModule","getSopClassHandlerModule","getUtilityModule","exports","state","trackingIdentifiersByViewportId","setTrackingUniqueIdentifiersForElement","getEnabledElement","ImageSet","findInstance","sopUid","referencedDisplaySet","images","findReferencedInstances","instanceById","createReferencedImageDisplaySet","imageSet","setAttributes","isMultiFrame","numImageFrames","isCompositeStack","madeInClient","excludeFromThumbnailBrowser","updateInstances","addDisplaySets"],"sourceRoot":""}