{"version":3,"file":"414.bundle.42268f734c721e43e9c2.js","mappings":"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","sources":["webpack:///../../../extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/promptBeginTracking.js","webpack:///../../../extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/measurementTrackingMachine.js","webpack:///../../../extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/hydrateStructuredReport.tsx","webpack:///../../../extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/promptWrapperFunctions.ts","webpack:///../../../extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/TrackedMeasurementsContext.tsx","webpack:///../../../extensions/measurement-tracking/src/getContextModule.tsx","webpack:///../../../extensions/measurement-tracking/src/panels/PanelStudyBrowserTracking/untrackSeriesModal.tsx","webpack:///../../../extensions/measurement-tracking/src/panels/PanelStudyBrowserTracking/PanelStudyBrowserTracking.tsx","webpack:///../../../extensions/measurement-tracking/src/panels/PanelStudyBrowserTracking/getImageSrcFromImageId.js","webpack:///../../../extensions/measurement-tracking/src/panels/PanelStudyBrowserTracking/index.tsx","webpack:///../../../extensions/measurement-tracking/src/panels/PanelMeasurementTableTracking.tsx","webpack:///../../../extensions/measurement-tracking/src/getPanelModule.tsx","webpack:///../../../extensions/measurement-tracking/src/getViewportModule.tsx","webpack:///../../../extensions/measurement-tracking/src/id.js","webpack:///../../../extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/promptHasDirtyAnnotations.ts","webpack:///../../../extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/promptHydrateStructuredReport.ts","webpack:///../../../extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/promptTrackNewSeries.js","webpack:///../../../extensions/measurement-tracking/src/contexts/TrackedMeasurementsContext/promptTrackNewStudy.ts","webpack:///../../../extensions/measurement-tracking/src/customizations/measurementTrackingPrompts.tsx","webpack:///../../../extensions/measurement-tracking/src/customizations/studyBrowserCustomization.ts","webpack:///../../../extensions/measurement-tracking/src/services/TrackedMeasurementsService/TrackedMeasurementsService.ts","webpack:///../../../extensions/measurement-tracking/src/index.tsx","webpack:///../../../extensions/measurement-tracking/src/getCustomizationModule.ts"],"sourcesContent":["import i18n from 'i18next';\n\nconst RESPONSE = {\n  NO_NEVER: -1,\n  CANCEL: 0,\n  CREATE_REPORT: 1,\n  ADD_SERIES: 2,\n  SET_STUDY_AND_SERIES: 3,\n};\n\nexport const measurementTrackingMode = {\n  STANDARD: 'standard',\n  SIMPLIFIED: 'simplified',\n  NONE: 'none',\n};\n\nfunction promptBeginTracking({ servicesManager, extensionManager }, ctx, evt) {\n  const { uiViewportDialogService, customizationService } = servicesManager.services;\n  const appConfig = extensionManager._appConfig;\n  // When the state change happens after a promise, the state machine sends the retult in evt.data;\n  // In case of direct transition to the state, the state machine sends the data in evt;\n  const { viewportId, StudyInstanceUID, SeriesInstanceUID } = evt.data || evt;\n\n  return new Promise(async function (resolve, reject) {\n    const standardMode = appConfig?.measurementTrackingMode === measurementTrackingMode.STANDARD;\n    const noTrackingMode = appConfig?.measurementTrackingMode === measurementTrackingMode.NONE;\n    let promptResult;\n\n    promptResult = noTrackingMode\n      ? RESPONSE.NO_NEVER\n      : standardMode\n        ? await _askTrackMeasurements(uiViewportDialogService, customizationService, viewportId)\n        : RESPONSE.SET_STUDY_AND_SERIES;\n\n    resolve({\n      userResponse: promptResult,\n      StudyInstanceUID,\n      SeriesInstanceUID,\n      viewportId,\n    });\n  });\n}\n\nfunction _askTrackMeasurements(uiViewportDialogService, customizationService, viewportId) {\n  return new Promise(function (resolve, reject) {\n    const message = customizationService.getCustomization(\n      'viewportNotification.beginTrackingMessage'\n    );\n    const actions = [\n      {\n        id: 'prompt-begin-tracking-cancel',\n        type: 'secondary',\n        text: i18n.t('Common:No'),\n        value: RESPONSE.CANCEL,\n      },\n      {\n        id: 'prompt-begin-tracking-no-do-not-ask-again',\n        type: 'secondary',\n        text: i18n.t('MeasurementTable:No, do not ask again'),\n        value: RESPONSE.NO_NEVER,\n      },\n      {\n        id: 'prompt-begin-tracking-yes',\n        type: 'primary',\n        text: i18n.t('Common:Yes'),\n        value: RESPONSE.SET_STUDY_AND_SERIES,\n      },\n    ];\n    const onSubmit = result => {\n      uiViewportDialogService.hide();\n      resolve(result);\n    };\n\n    uiViewportDialogService.show({\n      viewportId,\n      id: 'measurement-tracking-prompt-begin-tracking',\n      type: 'info',\n      message,\n      actions,\n      onSubmit,\n      onOutsideClick: () => {\n        uiViewportDialogService.hide();\n        resolve(RESPONSE.CANCEL);\n      },\n      onKeyPress: event => {\n        if (event.key === 'Enter') {\n          const action = actions.find(action => action.id === 'prompt-begin-tracking-yes');\n          onSubmit(action.value);\n        }\n      },\n    });\n  });\n}\n\nexport default promptBeginTracking;\n","import { assign } from 'xstate';\n\nconst RESPONSE = {\n  NO_NEVER: -1,\n  CANCEL: 0,\n  CREATE_REPORT: 1,\n  ADD_SERIES: 2,\n  SET_STUDY_AND_SERIES: 3,\n  NO_NOT_FOR_SERIES: 4,\n  HYDRATE_REPORT: 5,\n};\n\nconst machineConfiguration = {\n  id: 'measurementTracking',\n  initial: 'idle',\n  context: {\n    activeViewportId: null,\n    trackedStudy: '',\n    trackedSeries: [],\n    ignoredSeries: [],\n    //\n    prevTrackedStudy: '',\n    prevTrackedSeries: [],\n    prevIgnoredSeries: [],\n    //\n    ignoredSRSeriesForHydration: [],\n    isDirty: false,\n  },\n  states: {\n    off: {\n      type: 'final',\n    },\n    labellingOnly: {\n      on: {\n        TRACK_SERIES: [\n          {\n            target: 'promptLabelAnnotation',\n            actions: ['setPreviousState'],\n          },\n          {\n            target: 'off',\n          },\n        ],\n      },\n    },\n    idle: {\n      entry: 'clearContext',\n      on: {\n        TRACK_SERIES: [\n          {\n            target: 'promptLabelAnnotation',\n            cond: 'isLabelOnMeasure',\n            actions: ['setPreviousState'],\n          },\n          {\n            target: 'promptBeginTracking',\n            actions: ['setPreviousState'],\n          },\n        ],\n        SET_TRACKED_SERIES: [\n          {\n            target: 'tracking',\n            actions: ['setTrackedStudyAndMultipleSeries', 'setIsDirtyToClean'],\n          },\n        ],\n        PROMPT_HYDRATE_SR: {\n          target: 'promptHydrateStructuredReport',\n          cond: 'hasNotIgnoredSRSeriesForHydration',\n        },\n        RESTORE_PROMPT_HYDRATE_SR: 'promptHydrateStructuredReport',\n        HYDRATE_SR: 'hydrateStructuredReport',\n        UPDATE_ACTIVE_VIEWPORT_ID: {\n          actions: assign({\n            activeViewportId: (_, event) => event.activeViewportId,\n          }),\n        },\n      },\n    },\n    promptBeginTracking: {\n      invoke: {\n        src: 'promptBeginTracking',\n        onDone: [\n          {\n            target: 'tracking',\n            actions: ['setTrackedStudyAndSeries', 'setIsDirty'],\n            cond: 'shouldSetStudyAndSeries',\n          },\n          {\n            target: 'labellingOnly',\n            cond: 'isLabelOnMeasureAndShouldKillMachine',\n          },\n          {\n            target: 'off',\n            cond: 'shouldKillMachine',\n          },\n          {\n            target: 'idle',\n          },\n        ],\n        onError: {\n          target: 'idle',\n        },\n      },\n    },\n    tracking: {\n      on: {\n        TRACK_SERIES: [\n          {\n            target: 'promptLabelAnnotation',\n            cond: 'isLabelOnMeasure',\n            actions: ['setPreviousState'],\n          },\n          {\n            target: 'promptTrackNewStudy',\n            cond: 'isNewStudy',\n          },\n          {\n            target: 'promptTrackNewSeries',\n            cond: 'isNewSeries',\n          },\n        ],\n        UNTRACK_SERIES: [\n          {\n            target: 'tracking',\n            actions: ['removeTrackedSeries', 'setIsDirty', 'clearDisplaySetHydratedState'],\n            cond: 'hasRemainingTrackedSeries',\n          },\n          {\n            target: 'idle',\n          },\n        ],\n        UNTRACK_ALL: [\n          {\n            target: 'tracking',\n            actions: [\n              'clearContext',\n              'setIsDirtyToClean',\n              'clearDisplaySetHydratedState',\n              'clearAllMeasurements',\n            ],\n          },\n          {\n            target: 'idle',\n          },\n        ],\n        SET_TRACKED_SERIES: [\n          {\n            target: 'tracking',\n            actions: ['setTrackedStudyAndMultipleSeries'],\n          },\n        ],\n        SAVE_REPORT: 'promptSaveReport',\n        SET_DIRTY: [\n          {\n            target: 'tracking',\n            actions: ['setIsDirty'],\n            cond: 'shouldSetDirty',\n          },\n          {\n            target: 'tracking',\n          },\n        ],\n        CHECK_DIRTY: {\n          target: 'promptHasDirtyAnnotations',\n          cond: 'hasDirtyAndSimplified',\n        },\n        PROMPT_HYDRATE_SR: {\n          target: 'promptHydrateStructuredReport',\n          cond: 'isSimplifiedConfig',\n          actions: ['clearAllMeasurements', 'clearDisplaySetHydratedState'],\n        },\n      },\n    },\n    promptTrackNewSeries: {\n      invoke: {\n        src: 'promptTrackNewSeries',\n        onDone: [\n          {\n            target: 'tracking',\n            actions: ['addTrackedSeries', 'setIsDirty'],\n            cond: 'shouldAddSeries',\n          },\n          {\n            target: 'tracking',\n            actions: [\n              'discardPreviouslyTrackedMeasurements',\n              'setTrackedStudyAndSeries',\n              'setIsDirty',\n            ],\n            cond: 'shouldSetStudyAndSeries',\n          },\n          {\n            target: 'promptSaveReport',\n            cond: 'shouldPromptSaveReport',\n          },\n          {\n            target: 'tracking',\n          },\n        ],\n        onError: {\n          target: 'idle',\n        },\n      },\n    },\n    promptTrackNewStudy: {\n      invoke: {\n        src: 'promptTrackNewStudy',\n        onDone: [\n          {\n            target: 'tracking',\n            actions: [\n              'discardPreviouslyTrackedMeasurements',\n              'setTrackedStudyAndSeries',\n              'setIsDirty',\n            ],\n            cond: 'shouldSetStudyAndSeries',\n          },\n          {\n            target: 'tracking',\n            actions: ['ignoreSeries'],\n            cond: 'shouldAddIgnoredSeries',\n          },\n          {\n            target: 'promptSaveReport',\n            cond: 'shouldPromptSaveReport',\n          },\n          {\n            target: 'tracking',\n          },\n        ],\n        onError: {\n          target: 'idle',\n        },\n      },\n    },\n    promptSaveReport: {\n      invoke: {\n        src: 'promptSaveReport',\n        onDone: [\n          {\n            target: 'tracking',\n            actions: [\n              'clearAllMeasurements',\n              'clearDisplaySetHydratedState',\n              'setIsDirty',\n              'updatedViewports',\n            ],\n            cond: 'simplifiedAndLoadSR',\n          },\n          // \"clicked the save button\"\n          // - should clear all measurements\n          // - show DICOM SR\n          {\n            target: 'idle',\n            actions: ['clearAllMeasurements', 'showStructuredReportDisplaySetInActiveViewport'],\n            cond: 'shouldSaveAndContinueWithSameReport',\n          },\n          // \"starting a new report\"\n          // - remove \"just saved\" measurements\n          // - start tracking a new study + report\n          {\n            target: 'tracking',\n            actions: ['discardPreviouslyTrackedMeasurements', 'setTrackedStudyAndSeries'],\n            cond: 'shouldSaveAndStartNewReport',\n          },\n          // Cancel, back to tracking\n          {\n            target: 'tracking',\n          },\n        ],\n        onError: {\n          target: 'idle',\n        },\n      },\n    },\n    promptHydrateStructuredReport: {\n      invoke: {\n        src: 'promptHydrateStructuredReport',\n        onDone: [\n          {\n            target: 'tracking',\n            actions: [\n              'setTrackedStudyAndMultipleSeries',\n              'jumpToSameImageInActiveViewport',\n              'setIsDirtyToClean',\n            ],\n            cond: 'shouldHydrateStructuredReport',\n          },\n          {\n            target: 'idle',\n            actions: ['ignoreHydrationForSRSeries'],\n            cond: 'shouldIgnoreHydrationForSR',\n          },\n        ],\n        onError: {\n          target: 'idle',\n        },\n      },\n    },\n    hydrateStructuredReport: {\n      invoke: {\n        src: 'hydrateStructuredReport',\n        onDone: [\n          {\n            target: 'tracking',\n            actions: [\n              'setTrackedStudyAndMultipleSeries',\n              'jumpToSameImageInActiveViewport',\n              'setIsDirtyToClean',\n            ],\n          },\n        ],\n        onError: {\n          target: 'idle',\n        },\n      },\n    },\n    promptLabelAnnotation: {\n      invoke: {\n        src: 'promptLabelAnnotation',\n        onDone: [\n          {\n            target: 'labellingOnly',\n            cond: 'wasLabellingOnly',\n          },\n          {\n            target: 'promptBeginTracking',\n            cond: 'wasIdle',\n          },\n          {\n            target: 'promptTrackNewStudy',\n            cond: 'wasTrackingAndIsNewStudy',\n          },\n          {\n            target: 'promptTrackNewSeries',\n            cond: 'wasTrackingAndIsNewSeries',\n          },\n          {\n            target: 'tracking',\n            cond: 'wasTracking',\n          },\n          {\n            target: 'off',\n          },\n        ],\n      },\n    },\n    promptHasDirtyAnnotations: {\n      invoke: {\n        src: 'promptHasDirtyAnnotations',\n        onDone: [\n          {\n            target: 'tracking',\n            actions: [\n              'clearAllMeasurements',\n              'clearDisplaySetHydratedState',\n              'setIsDirty',\n              'updatedViewports',\n            ],\n            cond: 'shouldSetStudyAndSeries',\n          },\n          {\n            target: 'promptSaveReport',\n            cond: 'shouldPromptSaveReport',\n          },\n          { target: 'tracking' },\n        ],\n      },\n    },\n  },\n  strict: true,\n};\n\nconst defaultOptions = {\n  services: {\n    promptBeginTracking: (ctx, evt) => {\n      // return { userResponse, StudyInstanceUID, SeriesInstanceUID }\n    },\n    promptTrackNewStudy: (ctx, evt) => {\n      // return { userResponse, StudyInstanceUID, SeriesInstanceUID }\n    },\n    promptTrackNewSeries: (ctx, evt) => {\n      // return { userResponse, StudyInstanceUID, SeriesInstanceUID }\n    },\n  },\n  actions: {\n    discardPreviouslyTrackedMeasurements: (ctx, evt) => {\n      console.log('discardPreviouslyTrackedMeasurements: not implemented');\n    },\n    clearAllMeasurements: (ctx, evt) => {\n      console.log('clearAllMeasurements: not implemented');\n    },\n    jumpToFirstMeasurementInActiveViewport: (ctx, evt) => {\n      console.warn('jumpToFirstMeasurementInActiveViewport: not implemented');\n    },\n    showStructuredReportDisplaySetInActiveViewport: (ctx, evt) => {\n      console.warn('showStructuredReportDisplaySetInActiveViewport: not implemented');\n    },\n    clearContext: assign({\n      trackedStudy: '',\n      trackedSeries: [],\n      ignoredSeries: [],\n      prevTrackedStudy: '',\n      prevTrackedSeries: [],\n      prevIgnoredSeries: [],\n    }),\n    // Promise resolves w/ `evt.data.*`\n    setTrackedStudyAndSeries: assign((ctx, evt) => ({\n      prevTrackedStudy: ctx.trackedStudy,\n      prevTrackedSeries: ctx.trackedSeries.slice(),\n      prevIgnoredSeries: ctx.ignoredSeries.slice(),\n      //\n      trackedStudy: evt.data.StudyInstanceUID,\n      trackedSeries: [evt.data.SeriesInstanceUID],\n      ignoredSeries: [],\n    })),\n    setTrackedStudyAndMultipleSeries: assign((ctx, evt) => {\n      const studyInstanceUID = evt.StudyInstanceUID || evt.data.StudyInstanceUID;\n      const seriesInstanceUIDs = evt.SeriesInstanceUIDs || evt.data.SeriesInstanceUIDs;\n\n      return {\n        prevTrackedStudy: ctx.trackedStudy,\n        prevTrackedSeries: ctx.trackedSeries.slice(),\n        prevIgnoredSeries: ctx.ignoredSeries.slice(),\n        //\n        trackedStudy: studyInstanceUID,\n        trackedSeries: [...ctx.trackedSeries, ...seriesInstanceUIDs],\n        ignoredSeries: [],\n      };\n    }),\n    setIsDirtyToClean: assign((ctx, evt) => ({\n      isDirty: false,\n    })),\n    setIsDirty: assign((ctx, evt) => ({\n      isDirty: true,\n    })),\n    ignoreSeries: assign((ctx, evt) => ({\n      prevIgnoredSeries: [...ctx.ignoredSeries],\n      ignoredSeries: [...ctx.ignoredSeries, evt.data.SeriesInstanceUID],\n    })),\n    ignoreHydrationForSRSeries: assign((ctx, evt) => ({\n      ignoredSRSeriesForHydration: [\n        ...ctx.ignoredSRSeriesForHydration,\n        evt.data.srSeriesInstanceUID,\n      ],\n    })),\n    addTrackedSeries: assign((ctx, evt) => ({\n      prevTrackedSeries: [...ctx.trackedSeries],\n      trackedSeries: [...ctx.trackedSeries, evt.data.SeriesInstanceUID],\n    })),\n    removeTrackedSeries: assign((ctx, evt) => ({\n      prevTrackedSeries: ctx.trackedSeries.slice().filter(ser => ser !== evt.SeriesInstanceUID),\n      trackedSeries: ctx.trackedSeries.slice().filter(ser => ser !== evt.SeriesInstanceUID),\n    })),\n    setPreviousState: assign((ctx, evt, meta) => {\n      return {\n        prevState: meta.state.value,\n      };\n    }),\n  },\n  guards: {\n    // We set dirty any time we performan an action that:\n    // - Tracks a new study\n    // - Tracks a new series\n    // - Adds a measurement to an already tracked study/series\n    //\n    // We set clean any time we restore from an SR\n    //\n    // This guard/condition is specific to \"new measurements\"\n    // to make sure we only track dirty when the new measurement is specific\n    // to a series we're already tracking\n    //\n    // tl;dr\n    // Any report change, that is not a hydration of an existing report, should\n    // result in a \"dirty\" report\n    //\n    // Where dirty means there would be \"loss of data\" if we blew away measurements\n    // without creating a new SR.\n    shouldSetDirty: (ctx, evt) => {\n      return (\n        // When would this happen?\n        evt.SeriesInstanceUID === undefined || ctx.trackedSeries.includes(evt.SeriesInstanceUID)\n      );\n    },\n    wasLabellingOnly: (ctx, evt, condMeta) => {\n      return ctx.prevState === 'labellingOnly';\n    },\n    wasIdle: (ctx, evt, condMeta) => {\n      return ctx.prevState === 'idle';\n    },\n    wasTracking: (ctx, evt, condMeta) => {\n      return ctx.prevState === 'tracking';\n    },\n    wasTrackingAndIsNewStudy: (ctx, evt, condMeta) => {\n      return (\n        ctx.prevState === 'tracking' &&\n        !ctx.ignoredSeries.includes(evt.data.SeriesInstanceUID) &&\n        ctx.trackedStudy !== evt.data.StudyInstanceUID\n      );\n    },\n    wasTrackingAndIsNewSeries: (ctx, evt, condMeta) => {\n      return (\n        ctx.prevState === 'tracking' &&\n        !ctx.ignoredSeries.includes(evt.data.SeriesInstanceUID) &&\n        !ctx.trackedSeries.includes(evt.data.SeriesInstanceUID)\n      );\n    },\n\n    shouldKillMachine: (ctx, evt) => evt.data && evt.data.userResponse === RESPONSE.NO_NEVER,\n    shouldAddSeries: (ctx, evt) => evt.data && evt.data.userResponse === RESPONSE.ADD_SERIES,\n    shouldSetStudyAndSeries: (ctx, evt) =>\n      evt.data && evt.data.userResponse === RESPONSE.SET_STUDY_AND_SERIES,\n    shouldAddIgnoredSeries: (ctx, evt) =>\n      evt.data && evt.data.userResponse === RESPONSE.NO_NOT_FOR_SERIES,\n    shouldPromptSaveReport: (ctx, evt) =>\n      evt.data && evt.data.userResponse === RESPONSE.CREATE_REPORT,\n    shouldIgnoreHydrationForSR: (ctx, evt) => evt.data && evt.data.userResponse === RESPONSE.CANCEL,\n    shouldSaveAndContinueWithSameReport: (ctx, evt) =>\n      evt.data &&\n      evt.data.userResponse === RESPONSE.CREATE_REPORT &&\n      evt.data.isBackupSave === true,\n    shouldSaveAndStartNewReport: (ctx, evt) =>\n      evt.data &&\n      evt.data.userResponse === RESPONSE.CREATE_REPORT &&\n      evt.data.isBackupSave === false,\n    shouldHydrateStructuredReport: (ctx, evt) =>\n      evt.data && evt.data.userResponse === RESPONSE.HYDRATE_REPORT,\n    // Has more than 1, or SeriesInstanceUID is not in list\n    // --> Post removal would have non-empty trackedSeries array\n    hasRemainingTrackedSeries: (ctx, evt) =>\n      ctx.trackedSeries.length > 1 || !ctx.trackedSeries.includes(evt.SeriesInstanceUID),\n    hasNotIgnoredSRSeriesForHydration: (ctx, evt) => {\n      return !ctx.ignoredSRSeriesForHydration.includes(evt.SeriesInstanceUID);\n    },\n    isNewStudy: (ctx, evt) =>\n      !ctx.ignoredSeries.includes(evt.SeriesInstanceUID) &&\n      ctx.trackedStudy !== evt.StudyInstanceUID,\n    isNewSeries: (ctx, evt) =>\n      !ctx.ignoredSeries.includes(evt.SeriesInstanceUID) &&\n      !ctx.trackedSeries.includes(evt.SeriesInstanceUID),\n  },\n};\n\nexport { defaultOptions, machineConfiguration, RESPONSE };\n","import { hydrateStructuredReport as baseHydrateStructuredReport } from '@ohif/extension-cornerstone-dicom-sr';\n\nfunction hydrateStructuredReport(\n  { servicesManager, extensionManager, commandsManager, appConfig }: withAppTypes,\n  ctx,\n  evt\n) {\n  const { displaySetService } = servicesManager.services;\n  const { viewportId, displaySetInstanceUID } = evt;\n  const srDisplaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n  return new Promise((resolve, reject) => {\n    const hydrationResult = baseHydrateStructuredReport(\n      { servicesManager, extensionManager, commandsManager, appConfig },\n      displaySetInstanceUID\n    );\n\n    const StudyInstanceUID = hydrationResult.StudyInstanceUID;\n    const SeriesInstanceUIDs = hydrationResult.SeriesInstanceUIDs;\n\n    resolve({\n      displaySetInstanceUID: evt.displaySetInstanceUID,\n      srSeriesInstanceUID: srDisplaySet.SeriesInstanceUID,\n      viewportId,\n      StudyInstanceUID,\n      SeriesInstanceUIDs,\n    });\n  });\n}\n\nexport default hydrateStructuredReport;\n","const promptBeginTrackingWrapper = ({ servicesManager, extensionManager }, ctx, evt) => {\n  const { customizationService } = servicesManager.services;\n  const promptBeginTracking = customizationService.getCustomization(\n    'measurement.promptBeginTracking'\n  );\n  return promptBeginTracking({ servicesManager, extensionManager }, ctx, evt);\n};\n\nconst promptHydrateStructuredReportWrapper = (\n  { servicesManager, extensionManager, commandsManager, appConfig },\n  ctx,\n  evt\n) => {\n  const { customizationService } = servicesManager.services;\n  const promptHydrateStructuredReport = customizationService.getCustomization(\n    'measurement.promptHydrateStructuredReport'\n  );\n  return promptHydrateStructuredReport(\n    { servicesManager, extensionManager, commandsManager, appConfig },\n    ctx,\n    evt\n  );\n};\n\nconst promptTrackNewSeriesWrapper = ({ servicesManager, extensionManager }, ctx, evt) => {\n  const { customizationService } = servicesManager.services;\n  const promptTrackNewSeries = customizationService.getCustomization(\n    'measurement.promptTrackNewSeries'\n  );\n  return promptTrackNewSeries({ servicesManager, extensionManager }, ctx, evt);\n};\n\nconst promptTrackNewStudyWrapper = ({ servicesManager, extensionManager }, ctx, evt) => {\n  const { customizationService } = servicesManager.services;\n  const promptTrackNewStudy = customizationService.getCustomization(\n    'measurement.promptTrackNewStudy'\n  );\n  return promptTrackNewStudy({ servicesManager, extensionManager }, ctx, evt);\n};\n\nconst promptLabelAnnotationWrapper = ({ servicesManager }, ctx, evt) => {\n  const { customizationService } = servicesManager.services;\n  const promptLabelAnnotation = customizationService.getCustomization(\n    'measurement.promptLabelAnnotation'\n  );\n  return promptLabelAnnotation({ servicesManager }, ctx, evt);\n};\n\nconst promptSaveReportWrapper = (\n  { servicesManager, commandsManager, extensionManager },\n  ctx,\n  evt\n) => {\n  const { customizationService } = servicesManager.services;\n  const promptSaveReport = customizationService.getCustomization('measurement.promptSaveReport');\n  return promptSaveReport({ servicesManager, commandsManager, extensionManager }, ctx, evt);\n};\n\nconst promptHasDirtyAnnotationsWrapper = (\n  { servicesManager, commandsManager, extensionManager },\n  ctx,\n  evt\n) => {\n  const { customizationService } = servicesManager.services;\n  const promptHasDirtyAnnotations = customizationService.getCustomization(\n    'measurement.promptHasDirtyAnnotations'\n  );\n  return promptHasDirtyAnnotations(\n    { servicesManager, commandsManager, extensionManager },\n    ctx,\n    evt\n  );\n};\n\nexport {\n  promptBeginTrackingWrapper,\n  promptHydrateStructuredReportWrapper,\n  promptTrackNewSeriesWrapper,\n  promptTrackNewStudyWrapper,\n  promptLabelAnnotationWrapper,\n  promptSaveReportWrapper,\n  promptHasDirtyAnnotationsWrapper,\n};\n","import React, { useContext, useEffect, useMemo } from 'react';\nimport PropTypes from 'prop-types';\nimport { Machine } from 'xstate';\nimport { useMachine } from '@xstate/react';\nimport { useViewportGrid } from '@ohif/ui-next';\nimport { machineConfiguration, defaultOptions, RESPONSE } from './measurementTrackingMachine';\nimport { measurementTrackingMode } from './promptBeginTracking';\nimport hydrateStructuredReport from './hydrateStructuredReport';\nimport { useAppConfig } from '@state';\nimport {\n  promptBeginTrackingWrapper,\n  promptHydrateStructuredReportWrapper,\n  promptTrackNewSeriesWrapper,\n  promptTrackNewStudyWrapper,\n  promptLabelAnnotationWrapper,\n  promptSaveReportWrapper,\n  promptHasDirtyAnnotationsWrapper,\n} from './promptWrapperFunctions';\n\nconst TrackedMeasurementsContext = React.createContext();\nTrackedMeasurementsContext.displayName = 'TrackedMeasurementsContext';\nconst useTrackedMeasurements = () => useContext(TrackedMeasurementsContext);\n\nconst SR_SOP_CLASS_HANDLER_ID =\n  '@ohif/extension-cornerstone-dicom-sr.sopClassHandlerModule.dicom-sr';\nconst COMPREHENSIVE_3D_SR_SOP_CLASS_HANDLER_ID =\n  '@ohif/extension-cornerstone-dicom-sr.sopClassHandlerModule.dicom-sr-3d';\n\nconst hasValidSOPClassHandlerId = displaySet => {\n  return [SR_SOP_CLASS_HANDLER_ID, COMPREHENSIVE_3D_SR_SOP_CLASS_HANDLER_ID].includes(\n    displaySet.SOPClassHandlerId\n  );\n};\n\n/**\n *\n * @param {*} param0\n */\nfunction TrackedMeasurementsContextProvider(\n  { servicesManager, commandsManager, extensionManager }: withAppTypes, // Bound by consumer\n  { children } // Component props\n) {\n  const [appConfig] = useAppConfig();\n\n  const [viewportGrid, viewportGridService] = useViewportGrid();\n  const { activeViewportId, viewports } = viewportGrid;\n  const {\n    measurementService,\n    displaySetService,\n    customizationService,\n    trackedMeasurementsService,\n  } = servicesManager.services as AppTypes.Services;\n\n  const machineOptions = Object.assign({}, defaultOptions);\n  machineOptions.actions = Object.assign({}, machineOptions.actions, {\n    jumpToFirstMeasurementInActiveViewport: (ctx, evt) => {\n      const { trackedStudy, trackedSeries } = ctx;\n      const { viewportId: activeViewportId } = evt.data;\n      const measurements = measurementService.getMeasurements();\n      const trackedMeasurements = measurements.filter(\n        m => trackedStudy === m.referenceStudyUID && trackedSeries.includes(m.referenceSeriesUID)\n      );\n\n      console.log(\n        'jumping to measurement reset viewport',\n        activeViewportId,\n        trackedMeasurements[0]\n      );\n\n      const referencedDisplaySetUID = trackedMeasurements[0].displaySetInstanceUID;\n      const referencedDisplaySet = displaySetService.getDisplaySetByUID(referencedDisplaySetUID);\n\n      const referencedImages = referencedDisplaySet.images;\n      const isVolumeIdReferenced = referencedImages[0].imageId.startsWith('volumeId');\n\n      const measurementData = trackedMeasurements[0].data;\n\n      let imageIndex = 0;\n      if (!isVolumeIdReferenced && measurementData) {\n        // if it is imageId referenced find the index of the imageId, we don't have\n        // support for volumeId referenced images yet\n        imageIndex = referencedImages.findIndex(image => {\n          const imageIdToUse = Object.keys(measurementData)[0].substring(8);\n          return image.imageId === imageIdToUse;\n        });\n\n        if (imageIndex === -1) {\n          console.warn('Could not find image index for tracked measurement, using 0');\n          imageIndex = 0;\n        }\n      }\n\n      viewportGridService.setDisplaySetsForViewport({\n        viewportId: activeViewportId,\n        displaySetInstanceUIDs: [referencedDisplaySetUID],\n        viewportOptions: {\n          initialImageOptions: {\n            index: imageIndex,\n          },\n        },\n      });\n    },\n\n    jumpToSameImageInActiveViewport: (ctx, evt) => {\n      const { trackedStudy, trackedSeries } = ctx;\n      const { viewportId: activeViewportId } = evt.data;\n      const measurements = measurementService.getMeasurements();\n      const trackedMeasurements = measurements.filter(\n        m => trackedStudy === m.referenceStudyUID && trackedSeries.includes(m.referenceSeriesUID)\n      );\n\n      // Jump to the last tracked measurement - most recent\n      if (!trackedMeasurements?.length) {\n        console.warn(\n          \"Didn't find any tracked measurements\",\n          measurements,\n          trackedStudy,\n          trackedSeries\n        );\n        return;\n      }\n      const trackedMeasurement = trackedMeasurements[trackedMeasurements.length - 1];\n      const referencedDisplaySetUID = trackedMeasurement.displaySetInstanceUID;\n\n      // update the previously stored positionPresentation with the new viewportId\n      // presentation so that when we put the referencedDisplaySet back in the viewport\n      // it will be in the correct position zoom and pan\n      commandsManager.runCommand('updateStoredPositionPresentation', {\n        viewportId: activeViewportId,\n        displaySetInstanceUIDs: [referencedDisplaySetUID],\n        referencedImageId: trackedMeasurement.referencedImageId,\n      });\n\n      viewportGridService.setDisplaySetsForViewport({\n        viewportId: activeViewportId,\n        displaySetInstanceUIDs: [referencedDisplaySetUID],\n      });\n    },\n    showStructuredReportDisplaySetInActiveViewport: (ctx, evt) => {\n      if (evt.data.createdDisplaySetInstanceUIDs.length > 0) {\n        const StructuredReportDisplaySetInstanceUID = evt.data.createdDisplaySetInstanceUIDs[0];\n\n        viewportGridService.setDisplaySetsForViewport({\n          viewportId: evt.data.viewportId,\n          displaySetInstanceUIDs: [StructuredReportDisplaySetInstanceUID],\n        });\n      }\n    },\n    discardPreviouslyTrackedMeasurements: (ctx, evt) => {\n      const measurements = measurementService.getMeasurements();\n      const filteredMeasurements = measurements.filter(ms =>\n        ctx.prevTrackedSeries.includes(ms.referenceSeriesUID)\n      );\n      const measurementIds = filteredMeasurements.map(fm => fm.id);\n\n      for (let i = 0; i < measurementIds.length; i++) {\n        measurementService.remove(measurementIds[i]);\n      }\n    },\n    clearAllMeasurements: (ctx, evt) => {\n      measurementService.clearMeasurements();\n      measurementService.setIsMeasurementDeletedIndividually(false);\n    },\n    clearDisplaySetHydratedState: (ctx, evt) => {\n      const { displaySetInstanceUID } = evt.data ?? evt;\n\n      const displaysets = displaySetService.getActiveDisplaySets();\n      displaysets?.forEach(displayset => {\n        if (\n          displayset.Modality === 'SR' &&\n          displayset.displaySetInstanceUID !== displaySetInstanceUID &&\n          displayset.isHydrated\n        ) {\n          displayset.isHydrated = false;\n          displayset.isLoaded = false;\n        }\n      });\n    },\n    updatedViewports: (ctx, evt) => {\n      const { hangingProtocolService } = servicesManager.services;\n      const { displaySetInstanceUID, viewportId } = evt.data ?? evt;\n\n      const updatedViewports = hangingProtocolService.getViewportsRequireUpdate(\n        viewportId,\n        displaySetInstanceUID\n      );\n\n      viewportGridService.setDisplaySetsForViewports(updatedViewports);\n    },\n  });\n  machineOptions.services = Object.assign({}, machineOptions.services, {\n    promptBeginTracking: promptBeginTrackingWrapper.bind(null, {\n      servicesManager,\n      extensionManager,\n      appConfig,\n    }),\n    promptTrackNewSeries: promptTrackNewSeriesWrapper.bind(null, {\n      servicesManager,\n      extensionManager,\n      appConfig,\n    }),\n    promptTrackNewStudy: promptTrackNewStudyWrapper.bind(null, {\n      servicesManager,\n      extensionManager,\n      appConfig,\n    }),\n    promptSaveReport: promptSaveReportWrapper.bind(null, {\n      servicesManager,\n      commandsManager,\n      extensionManager,\n      appConfig,\n    }),\n    promptHydrateStructuredReport: promptHydrateStructuredReportWrapper.bind(null, {\n      servicesManager,\n      extensionManager,\n      commandsManager,\n      appConfig,\n    }),\n    promptHasDirtyAnnotations: promptHasDirtyAnnotationsWrapper.bind(null, {\n      servicesManager,\n      extensionManager,\n      commandsManager,\n      appConfig,\n    }),\n    hydrateStructuredReport: hydrateStructuredReport.bind(null, {\n      servicesManager,\n      extensionManager,\n      commandsManager,\n      appConfig,\n    }),\n    promptLabelAnnotation: promptLabelAnnotationWrapper.bind(null, {\n      servicesManager,\n      extensionManager,\n      commandsManager,\n    }),\n  });\n  machineOptions.guards = Object.assign({}, machineOptions.guards, {\n    isLabelOnMeasure: (ctx, evt, condMeta) => {\n      const labelConfig = customizationService.getCustomization('measurementLabels');\n      return labelConfig?.labelOnMeasure;\n    },\n    isLabelOnMeasureAndShouldKillMachine: (ctx, evt, condMeta) => {\n      const labelConfig = customizationService.getCustomization('measurementLabels');\n      return evt.data && evt.data.userResponse === RESPONSE.NO_NEVER && labelConfig?.labelOnMeasure;\n    },\n    isSimplifiedConfig: (ctx, evt, condMeta) => {\n      return appConfig?.measurementTrackingMode === measurementTrackingMode.SIMPLIFIED;\n    },\n    simplifiedAndLoadSR: (ctx, evt, condMeta) => {\n      return (\n        appConfig?.measurementTrackingMode === measurementTrackingMode.SIMPLIFIED &&\n        evt.data.isBackupSave === false\n      );\n    },\n    hasDirtyAndSimplified: (ctx, evt, condMeta) => {\n      const measurements = measurementService.getMeasurements();\n      const hasDirtyMeasurements =\n        measurements.some(measurement => measurement.isDirty) ||\n        (measurements.length && measurementService.getIsMeasurementDeletedIndividually());\n      return (\n        appConfig?.measurementTrackingMode === measurementTrackingMode.SIMPLIFIED &&\n        hasDirtyMeasurements\n      );\n    },\n  });\n\n  // TODO: IMPROVE\n  // - Add measurement_updated to cornerstone; debounced? (ext side, or consumption?)\n  // - Friendlier transition/api in front of measurementTracking machine?\n  // - Blocked: viewport overlay shouldn't clip when resized\n  // TODO: PRIORITY\n  // - Fix \"ellipses\" series description dynamic truncate length\n  // - Fix viewport border resize\n  // - created/destroyed hooks for extensions (cornerstone measurement subscriptions in it's `init`)\n\n  const measurementTrackingMachine = useMemo(() => {\n    return Machine(machineConfiguration, machineOptions);\n  }, []); // Empty dependency array ensures this is only created once\n\n  const [trackedMeasurements, sendTrackedMeasurementsEvent] = useMachine(\n    measurementTrackingMachine\n  );\n\n  // Update TrackedMeasurementsService when trackedSeries changes in context\n  useEffect(() => {\n    if (trackedMeasurements?.context?.trackedSeries && trackedMeasurementsService) {\n      trackedMeasurementsService.updateTrackedSeries(trackedMeasurements.context.trackedSeries);\n    }\n  }, [trackedMeasurements?.context?.trackedSeries, trackedMeasurementsService]);\n\n  useEffect(() => {\n    // Update the state machine with the active viewport ID\n    sendTrackedMeasurementsEvent('UPDATE_ACTIVE_VIEWPORT_ID', {\n      activeViewportId,\n    });\n  }, [activeViewportId, sendTrackedMeasurementsEvent]);\n\n  // ~~ Listen for changes to ViewportGrid for potential SRs hung in panes when idle\n  useEffect(() => {\n    const triggerPromptHydrateFlow = async () => {\n      if (viewports.size > 0) {\n        const activeViewport = viewports.get(activeViewportId);\n\n        if (!activeViewport || !activeViewport?.displaySetInstanceUIDs?.length) {\n          return;\n        }\n\n        // Todo: Getting the first displaySetInstanceUID is wrong, but we don't have\n        // tracking fusion viewports yet. This should change when we do.\n        const { displaySetService } = servicesManager.services;\n        const displaySet = displaySetService.getDisplaySetByUID(\n          activeViewport.displaySetInstanceUIDs[0]\n        );\n\n        if (!displaySet) {\n          return;\n        }\n\n        // If this is an SR produced by our SR SOPClassHandler,\n        // and it hasn't been loaded yet, do that now so we\n        // can check if it can be rehydrated or not.\n        //\n        // Note: This happens:\n        // - If the viewport is not currently an OHIFCornerstoneSRViewport\n        // - If the displaySet has never been hung\n        //\n        // Otherwise, the displaySet will be loaded by the useEffect handler\n        // listening to displaySet changes inside OHIFCornerstoneSRViewport.\n        // The issue here is that this handler in TrackedMeasurementsContext\n        // ends up occurring before the Viewport is created, so the displaySet\n        // is not loaded yet, and isRehydratable is undefined unless we call load().\n        if (hasValidSOPClassHandlerId(displaySet) && !displaySet.isLoaded && displaySet.load) {\n          await displaySet.load();\n        }\n\n        // Magic string\n        // load function added by our sopClassHandler module\n        if (\n          hasValidSOPClassHandlerId(displaySet) &&\n          displaySet.isRehydratable === true &&\n          !displaySet.isHydrated\n        ) {\n          const params = {\n            displaySetInstanceUID: displaySet.displaySetInstanceUID,\n            SeriesInstanceUID: displaySet.SeriesInstanceUID,\n            viewportId: activeViewportId,\n          };\n\n          // Check if we should bypass the confirmation prompt\n          const disableConfirmationPrompts = appConfig?.disableConfirmationPrompts;\n\n          if (disableConfirmationPrompts) {\n            sendTrackedMeasurementsEvent('HYDRATE_SR', params);\n          } else {\n            sendTrackedMeasurementsEvent('PROMPT_HYDRATE_SR', params);\n          }\n        }\n      }\n    };\n    triggerPromptHydrateFlow();\n  }, [\n    trackedMeasurements,\n    activeViewportId,\n    sendTrackedMeasurementsEvent,\n    servicesManager.services,\n    viewports,\n    appConfig,\n  ]);\n\n  useEffect(() => {\n    // The command needs to be bound to the context's sendTrackedMeasurementsEvent\n    // so the command has to be registered in a React component.\n    commandsManager.registerCommand('DEFAULT', 'loadTrackedSRMeasurements', {\n      commandFn: props => sendTrackedMeasurementsEvent('HYDRATE_SR', props),\n    });\n  }, [commandsManager, sendTrackedMeasurementsEvent]);\n\n  return (\n    <TrackedMeasurementsContext.Provider\n      value={[trackedMeasurements, sendTrackedMeasurementsEvent]}\n    >\n      {children}\n    </TrackedMeasurementsContext.Provider>\n  );\n}\n\nTrackedMeasurementsContextProvider.propTypes = {\n  children: PropTypes.oneOf([PropTypes.func, PropTypes.node]),\n  appConfig: PropTypes.object,\n};\n\nexport { TrackedMeasurementsContext, TrackedMeasurementsContextProvider, useTrackedMeasurements };\n","import {\n  TrackedMeasurementsContext,\n  TrackedMeasurementsContextProvider,\n  useTrackedMeasurements,\n} from './contexts';\n\nfunction getContextModule({ servicesManager, extensionManager, commandsManager }) {\n  const BoundTrackedMeasurementsContextProvider = TrackedMeasurementsContextProvider.bind(null, {\n    servicesManager,\n    extensionManager,\n    commandsManager,\n  });\n\n  return [\n    {\n      name: 'TrackedMeasurementsContext',\n      context: TrackedMeasurementsContext,\n      provider: BoundTrackedMeasurementsContextProvider,\n    },\n  ];\n}\n\nexport { useTrackedMeasurements };\nexport default getContextModule;\n","import React from 'react';\nimport { FooterAction } from '@ohif/ui-next';\n\nexport function UntrackSeriesModal({ hide, onConfirm, message }) {\n  return (\n    <div className=\"text-foreground text-[13px]\">\n      <div>\n        <p>{message}</p>\n        <p className=\"mt-2\">\n          This action cannot be undone and will delete all your existing measurements.\n        </p>\n      </div>\n      <FooterAction className=\"mt-4\">\n        <FooterAction.Right>\n          <FooterAction.Secondary onClick={hide}>Cancel</FooterAction.Secondary>\n          <FooterAction.Primary\n            onClick={() => {\n              onConfirm();\n              hide();\n            }}\n          >\n            Untrack\n          </FooterAction.Primary>\n        </FooterAction.Right>\n      </FooterAction>\n    </div>\n  );\n}\n","import React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { useSystem } from '@ohif/core';\nimport PanelStudyBrowser from '@ohif/extension-default/src/Panels/StudyBrowser/PanelStudyBrowser';\nimport { UntrackSeriesModal } from './untrackSeriesModal';\nimport { useTrackedMeasurements } from '../../getContextModule';\n\nconst thumbnailNoImageModalities = ['SR', 'SEG', 'RTSTRUCT', 'RTPLAN', 'RTDOSE', 'PMAP'];\n\n/**\n * Panel component for the Study Browser with tracking capabilities\n */\nexport default function PanelStudyBrowserTracking({\n  getImageSrc,\n  getStudiesForPatientByMRN,\n  requestDisplaySetCreationForStudy,\n  dataSource,\n}) {\n  const { servicesManager } = useSystem();\n  const { displaySetService, uiModalService, measurementService, viewportGridService } =\n    servicesManager.services;\n  const [trackedMeasurements, sendTrackedMeasurementsEvent] = useTrackedMeasurements();\n  const { trackedSeries } = trackedMeasurements.context;\n\n  const checkDirtyMeasurements = displaySetInstanceUID => {\n    const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n    if (displaySet.Modality === 'SR' || displaySet.Modality === 'ANN') {\n      const activeViewportId = viewportGridService.getActiveViewportId();\n      sendTrackedMeasurementsEvent('CHECK_DIRTY', {\n        viewportId: activeViewportId,\n        displaySetInstanceUID: displaySetInstanceUID,\n      });\n    }\n  };\n\n  useEffect(() => {\n    const subscriptionOndropFired = viewportGridService.subscribe(\n      viewportGridService.EVENTS.VIEWPORT_ONDROP_HANDLED,\n      ({ eventData }) => {\n        checkDirtyMeasurements(eventData.displaySetInstanceUID);\n      }\n    );\n\n    return () => {\n      subscriptionOndropFired.unsubscribe();\n    };\n  }, []);\n  const onClickUntrack = displaySetInstanceUID => {\n    const onConfirm = () => {\n      const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n      sendTrackedMeasurementsEvent('UNTRACK_SERIES', {\n        SeriesInstanceUID: displaySet.SeriesInstanceUID,\n      });\n      const measurements = measurementService.getMeasurements();\n      measurements.forEach(m => {\n        if (m.referenceSeriesUID === displaySet.SeriesInstanceUID) {\n          measurementService.remove(m.uid);\n        }\n      });\n    };\n\n    uiModalService.show({\n      title: 'Untrack Series',\n      content: UntrackSeriesModal,\n      contentProps: {\n        onConfirm,\n        message: 'Are you sure you want to untrack this series?',\n      },\n    });\n  };\n\n  // Custom mapping function to add tracking data to display sets\n  const mapDisplaySetsWithTracking = (\n    displaySets,\n    displaySetLoadingState,\n    thumbnailImageSrcMap,\n    viewports\n  ) => {\n    const thumbnailDisplaySets = [];\n    const thumbnailNoImageDisplaySets = [];\n    displaySets\n      .filter(ds => !ds.excludeFromThumbnailBrowser)\n      .forEach(ds => {\n        const { thumbnailSrc, displaySetInstanceUID } = ds;\n        const componentType = getComponentType(ds);\n\n        const array =\n          componentType === 'thumbnailTracked' ? thumbnailDisplaySets : thumbnailNoImageDisplaySets;\n\n        const loadingProgress = displaySetLoadingState?.[displaySetInstanceUID];\n\n        array.push({\n          displaySetInstanceUID,\n          description: ds.SeriesDescription || '',\n          seriesNumber: ds.SeriesNumber,\n          modality: ds.Modality,\n          seriesDate: ds.SeriesDate ? new Date(ds.SeriesDate).toLocaleDateString() : '',\n          numInstances: ds.numImageFrames,\n          loadingProgress,\n          countIcon: ds.countIcon,\n          messages: ds.messages,\n          StudyInstanceUID: ds.StudyInstanceUID,\n          componentType,\n          imageSrc: thumbnailSrc || thumbnailImageSrcMap[displaySetInstanceUID],\n          dragData: {\n            type: 'displayset',\n            displaySetInstanceUID,\n          },\n          isTracked: trackedSeries.includes(ds.SeriesInstanceUID),\n          isHydratedForDerivedDisplaySet: ds.isHydrated,\n        });\n      });\n\n    return [...thumbnailDisplaySets, ...thumbnailNoImageDisplaySets];\n  };\n\n  // Override component type to use tracking specific components\n  const getComponentType = ds => {\n    if (\n      thumbnailNoImageModalities.includes(ds.Modality) ||\n      ds.unsupported ||\n      ds.thumbnailSrc === null\n    ) {\n      return 'thumbnailNoImage';\n    }\n    return 'thumbnailTracked';\n  };\n\n  return (\n    <PanelStudyBrowser\n      getImageSrc={getImageSrc}\n      getStudiesForPatientByMRN={getStudiesForPatientByMRN}\n      requestDisplaySetCreationForStudy={requestDisplaySetCreationForStudy}\n      dataSource={dataSource}\n      customMapDisplaySets={mapDisplaySetsWithTracking}\n      onClickUntrack={onClickUntrack}\n      onDoubleClickThumbnailHandlerCallBack={checkDirtyMeasurements}\n    />\n  );\n}\n\nPanelStudyBrowserTracking.propTypes = {\n  dataSource: PropTypes.shape({\n    getImageIdsForDisplaySet: PropTypes.func.isRequired,\n  }).isRequired,\n  getImageSrc: PropTypes.func.isRequired,\n  getStudiesForPatientByMRN: PropTypes.func.isRequired,\n  requestDisplaySetCreationForStudy: PropTypes.func.isRequired,\n};\n","/**\n * @param {*} cornerstone\n * @param {*} imageId\n */\nfunction getImageSrcFromImageId(cornerstone, imageId) {\n  return new Promise((resolve, reject) => {\n    const canvas = document.createElement('canvas');\n    cornerstone.utilities\n      .loadImageToCanvas({ canvas, imageId, thumbnail: true })\n      .then(imageId => {\n        resolve(canvas.toDataURL());\n      })\n      .catch(reject);\n  });\n}\n\nexport default getImageSrcFromImageId;\n","import React, { useCallback } from 'react';\n//\nimport PanelStudyBrowserTracking from './PanelStudyBrowserTracking';\nimport getImageSrcFromImageId from './getImageSrcFromImageId';\nimport { requestDisplaySetCreationForStudy } from '@ohif/extension-default';\nimport { useSystem } from '@ohif/core';\n\nfunction _getStudyForPatientUtility(extensionManager) {\n  const utilityModule = extensionManager.getModuleEntry(\n    '@ohif/extension-default.utilityModule.common'\n  );\n\n  const { getStudiesForPatientByMRN } = utilityModule.exports;\n  return getStudiesForPatientByMRN;\n}\n\n/**\n * Wraps the PanelStudyBrowser and provides features afforded by managers/services\n *\n * @param {object} params\n * @param {object} commandsManager\n * @param {object} extensionManager\n */\nfunction WrappedPanelStudyBrowserTracking() {\n  const { extensionManager } = useSystem();\n  const dataSource = extensionManager.getActiveDataSource()[0];\n\n  const getStudiesForPatientByMRN = _getStudyForPatientUtility(extensionManager);\n  const _getStudiesForPatientByMRN = getStudiesForPatientByMRN.bind(null, dataSource);\n  const _getImageSrcFromImageId = useCallback(\n    _createGetImageSrcFromImageIdFn(extensionManager),\n    []\n  );\n  const _requestDisplaySetCreationForStudy = requestDisplaySetCreationForStudy.bind(\n    null,\n    dataSource\n  );\n\n  return (\n    <PanelStudyBrowserTracking\n      dataSource={dataSource}\n      getImageSrc={_getImageSrcFromImageId}\n      getStudiesForPatientByMRN={_getStudiesForPatientByMRN}\n      requestDisplaySetCreationForStudy={_requestDisplaySetCreationForStudy}\n    />\n  );\n}\n\n/**\n * Grabs cornerstone library reference using a dependent command from\n * the @ohif/extension-cornerstone extension. Then creates a helper function\n * that can take an imageId and return an image src.\n *\n * @param {func} getCommand - CommandManager's getCommand method\n * @returns {func} getImageSrcFromImageId - A utility function powered by\n * cornerstone\n */\nfunction _createGetImageSrcFromImageIdFn(extensionManager) {\n  const utilities = extensionManager.getModuleEntry(\n    '@ohif/extension-cornerstone.utilityModule.common'\n  );\n\n  try {\n    const { cornerstone } = utilities.exports.getCornerstoneLibraries();\n    return getImageSrcFromImageId.bind(null, cornerstone);\n  } catch (ex) {\n    throw new Error('Required command not found');\n  }\n}\n\nexport default WrappedPanelStudyBrowserTracking;\n","import React from 'react';\nimport { useSystem, utils } from '@ohif/core';\nimport { AccordionTrigger, MeasurementTable, ScrollArea, useViewportGrid } from '@ohif/ui-next';\nimport {\n  PanelMeasurement,\n  StudyMeasurements,\n  StudySummaryFromMetadata,\n  AccordionGroup,\n  StudyMeasurementsActions,\n  MeasurementsOrAdditionalFindings,\n} from '@ohif/extension-cornerstone';\n\nimport { useTrackedMeasurements } from '../getContextModule';\nimport { UntrackSeriesModal } from './PanelStudyBrowserTracking/untrackSeriesModal';\n\nconst { filterMeasurementsBySeriesUID, filterAny } = utils.MeasurementFilters;\n\nfunction PanelMeasurementTableTracking(props) {\n  const [viewportGrid] = useViewportGrid();\n  const { servicesManager } = useSystem();\n  const { measurementService, uiModalService } = servicesManager.services;\n\n  const [trackedMeasurements, sendTrackedMeasurementsEvent] = useTrackedMeasurements();\n  const { trackedStudy, trackedSeries } = trackedMeasurements.context;\n  const measurementFilter = trackedStudy ? filterMeasurementsBySeriesUID(trackedSeries) : filterAny;\n\n  const onUntrackConfirm = () => {\n    sendTrackedMeasurementsEvent('UNTRACK_ALL', {});\n  };\n\n  const onDelete = () => {\n    const hasDirtyMeasurements = measurementService\n      .getMeasurements()\n      .some(measurement => measurement.isDirty);\n    hasDirtyMeasurements\n      ? uiModalService.show({\n          title: 'Untrack Study',\n          content: UntrackSeriesModal,\n          contentProps: {\n            onConfirm: onUntrackConfirm,\n            message: 'Are you sure you want to untrack study and delete all measurements?',\n          },\n        })\n      : onUntrackConfirm();\n  };\n\n  const EmptyComponent = () => (\n    <div data-cy=\"trackedMeasurements-panel\">\n      <MeasurementTable\n        title=\"Measurements\"\n        isExpanded={false}\n      >\n        <MeasurementTable.Body />\n      </MeasurementTable>\n    </div>\n  );\n\n  const actions = {\n    createSR: ({ StudyInstanceUID }) => {\n      sendTrackedMeasurementsEvent('SAVE_REPORT', {\n        viewportId: viewportGrid.activeViewportId,\n        isBackupSave: true,\n        StudyInstanceUID,\n        measurementFilter,\n      });\n    },\n    onDelete,\n  };\n\n  const Header = props => (\n    <AccordionTrigger\n      asChild={true}\n      className=\"px-0\"\n    >\n      <div data-cy=\"TrackingHeader\">\n        <StudySummaryFromMetadata\n          {...props}\n          actions={actions}\n        />\n      </div>\n    </AccordionTrigger>\n  );\n\n  return (\n    <ScrollArea>\n      <div data-cy=\"trackedMeasurements-panel\">\n        <PanelMeasurement\n          measurementFilter={measurementFilter}\n          emptyComponent={EmptyComponent}\n          sourceChildren={props.children}\n        >\n          <StudyMeasurements grouping={props.grouping}>\n            <AccordionGroup.Trigger\n              key=\"trackingMeasurementsHeader\"\n              asChild={true}\n            >\n              <Header key=\"trackingHeadChild\" />\n            </AccordionGroup.Trigger>\n            <MeasurementsOrAdditionalFindings\n              key=\"measurementsOrAdditionalFindings\"\n              activeStudyUID={trackedStudy}\n              customHeader={StudyMeasurementsActions}\n              measurementFilter={measurementFilter}\n              actions={actions}\n            />\n          </StudyMeasurements>\n        </PanelMeasurement>\n      </div>\n    </ScrollArea>\n  );\n}\n\nexport default PanelMeasurementTableTracking;\n","import { Types } from '@ohif/core';\nimport { PanelMeasurementTableTracking, PanelStudyBrowserTracking } from './panels';\nimport i18n from 'i18next';\nimport React from 'react';\n\n// TODO:\n// - No loading UI exists yet\n// - cancel promises when component is destroyed\n// - show errors in UI for thumbnails if promise fails\n\nfunction getPanelModule({ commandsManager, extensionManager, servicesManager }): Types.Panel[] {\n  return [\n    {\n      name: 'seriesList',\n      iconName: 'tab-studies',\n      iconLabel: 'Studies',\n      label: i18n.t('SidePanel:Studies'),\n      component: props => <PanelStudyBrowserTracking {...props} />,\n    },\n    {\n      name: 'trackedMeasurements',\n      iconName: 'tab-linear',\n      iconLabel: 'Measure',\n      label: i18n.t('SidePanel:Measurements'),\n      component: props => (\n        <PanelMeasurementTableTracking\n          {...props}\n          key=\"trackedMeasurements-panel\"\n          commandsManager={commandsManager}\n          extensionManager={extensionManager}\n          servicesManager={servicesManager}\n        />\n      ),\n    },\n  ];\n}\n\nexport default getPanelModule;\n","import React from 'react';\nimport { utils } from '@ohif/extension-cornerstone';\n\nconst Component = React.lazy(() => {\n  return import(/* webpackPrefetch: true */ './viewports/TrackedCornerstoneViewport');\n});\n\nconst OHIFCornerstoneViewport = props => {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <Component {...props} />\n    </React.Suspense>\n  );\n};\n\nfunction getViewportModule({ servicesManager, commandsManager, extensionManager }) {\n  const ExtendedOHIFCornerstoneTrackingViewport = props => {\n    return (\n      <OHIFCornerstoneViewport\n        servicesManager={servicesManager}\n        commandsManager={commandsManager}\n        extensionManager={extensionManager}\n        {...props}\n      />\n    );\n  };\n\n  return [\n    {\n      name: 'cornerstone-tracked',\n      component: ExtendedOHIFCornerstoneTrackingViewport,\n      isReferenceViewable: utils.isReferenceViewable.bind(null, servicesManager),\n    },\n  ];\n}\n\nexport default getViewportModule;\n","import packageJson from '../package.json';\n\nconst id = packageJson.name;\n\nexport { id };\n","const RESPONSE = {\n  NO_NEVER: -1,\n  CANCEL: 0,\n  CREATE_REPORT: 1,\n  ADD_SERIES: 2,\n  SET_STUDY_AND_SERIES: 3,\n  NO_NOT_FOR_SERIES: 4,\n};\n\nfunction promptHasDirtyAnnotations({ servicesManager }: withAppTypes, ctx, evt) {\n  const { viewportId, displaySetInstanceUID } = evt.data || evt;\n\n  return new Promise(async function (resolve, reject) {\n    const { uiViewportDialogService, customizationService } = servicesManager.services;\n\n    const promptResult = await _askSaveDiscardOrCancel(\n      uiViewportDialogService,\n      customizationService,\n      viewportId\n    );\n\n    resolve({\n      displaySetInstanceUID,\n      userResponse: promptResult,\n      viewportId,\n      isBackupSave: false,\n    });\n  });\n}\n\nfunction _askSaveDiscardOrCancel(\n  UIViewportDialogService: AppTypes.UIViewportDialogService,\n  customizationService: AppTypes.CustomizationService,\n  viewportId\n) {\n  return new Promise(function (resolve, reject) {\n    const message = customizationService.getCustomization(\n      'viewportNotification.discardDirtyMessage'\n    );\n    const actions = [\n      { id: 'cancel', type: 'cancel', text: 'Cancel', value: RESPONSE.CANCEL },\n      {\n        id: 'discard-existing',\n        type: 'secondary',\n        text: 'No, discard existing',\n        value: RESPONSE.SET_STUDY_AND_SERIES,\n      },\n      {\n        id: 'save-existing',\n        type: 'primary',\n        text: 'Yes',\n        value: RESPONSE.CREATE_REPORT,\n      },\n    ];\n    const onSubmit = result => {\n      UIViewportDialogService.hide();\n      resolve(result);\n    };\n\n    UIViewportDialogService.show({\n      viewportId,\n      id: 'measurement-tracking-prompt-dirty-measurement',\n      type: 'info',\n      message,\n      actions,\n      onSubmit,\n      onOutsideClick: () => {\n        UIViewportDialogService.hide();\n        resolve(RESPONSE.CANCEL);\n      },\n      onKeyPress: event => {\n        if (event.key === 'Enter') {\n          const action = actions.find(action => action.id === 'save-existing');\n          onSubmit(action.value);\n        }\n      },\n    });\n  });\n}\n\nexport default promptHasDirtyAnnotations;\n","import { utils } from '@ohif/extension-cornerstone';\n\nfunction promptHydrateStructuredReport({ servicesManager, commandsManager }, ctx, evt) {\n  const { displaySetService } = servicesManager.services;\n  const { viewportId, displaySetInstanceUID } = evt;\n  const srDisplaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n  const hydrateCallback = async () => {\n    return commandsManager.runCommand('hydrateSecondaryDisplaySet', {\n      displaySet: srDisplaySet,\n      viewportId,\n    });\n  };\n\n  // For SR we need to use the whole context\n  const enhancedSrDisplaySet = {\n    ...srDisplaySet,\n    displaySetInstanceUID,\n  };\n\n  return utils.promptHydrationDialog({\n    servicesManager,\n    viewportId,\n    displaySet: enhancedSrDisplaySet,\n    hydrateCallback,\n    type: 'SR',\n  });\n}\n\nexport default promptHydrateStructuredReport;\n","import { measurementTrackingMode } from './promptBeginTracking';\n\nconst RESPONSE = {\n  NO_NEVER: -1,\n  CANCEL: 0,\n  CREATE_REPORT: 1,\n  ADD_SERIES: 2,\n  SET_STUDY_AND_SERIES: 3,\n  NO_NOT_FOR_SERIES: 4,\n};\n\nfunction promptTrackNewSeries({ servicesManager, extensionManager }, ctx, evt) {\n  const { UIViewportDialogService, customizationService } = servicesManager.services;\n  // When the state change happens after a promise, the state machine sends the retult in evt.data;\n  // In case of direct transition to the state, the state machine sends the data in evt;\n  const { viewportId, StudyInstanceUID, SeriesInstanceUID } = evt.data || evt;\n\n  return new Promise(async function (resolve, reject) {\n    const appConfig = extensionManager._appConfig;\n\n    const showPrompt = appConfig?.measurementTrackingMode === measurementTrackingMode.STANDARD;\n    let promptResult = showPrompt\n      ? await _askShouldAddMeasurements(UIViewportDialogService, customizationService, viewportId)\n      : RESPONSE.ADD_SERIES;\n\n    if (promptResult === RESPONSE.CREATE_REPORT) {\n      promptResult = ctx.isDirty\n        ? await _askSaveDiscardOrCancel(UIViewportDialogService, customizationService, viewportId)\n        : RESPONSE.SET_STUDY_AND_SERIES;\n    }\n\n    resolve({\n      userResponse: promptResult,\n      StudyInstanceUID,\n      SeriesInstanceUID,\n      viewportId,\n      isBackupSave: false,\n    });\n  });\n}\n\nfunction _askShouldAddMeasurements(uiViewportDialogService, customizationService, viewportId) {\n  return new Promise(function (resolve, reject) {\n    const message = customizationService.getCustomization(\n      'viewportNotification.trackNewSeriesMessage'\n    );\n    const actions = [\n      {\n        type: 'secondary',\n        text: 'Cancel',\n        value: RESPONSE.CANCEL,\n      },\n      {\n        type: 'primary',\n        text: 'Create new report',\n        value: RESPONSE.CREATE_REPORT,\n      },\n      {\n        type: 'primary',\n        text: 'Add to existing report',\n        value: RESPONSE.ADD_SERIES,\n      },\n    ];\n    const onSubmit = result => {\n      uiViewportDialogService.hide();\n      resolve(result);\n    };\n\n    uiViewportDialogService.show({\n      viewportId,\n      type: 'info',\n      message,\n      actions,\n      onSubmit,\n      onOutsideClick: () => {\n        uiViewportDialogService.hide();\n        resolve(RESPONSE.CANCEL);\n      },\n    });\n  });\n}\n\nfunction _askSaveDiscardOrCancel(UIViewportDialogService, customizationService, viewportId) {\n  return new Promise(function (resolve, reject) {\n    const message = customizationService.getCustomization(\n      'viewportNotification.discardSeriesMessage'\n    );\n\n    const actions = [\n      { type: 'secondary', text: 'Cancel', value: RESPONSE.CANCEL },\n      {\n        type: 'secondary',\n        text: 'Save',\n        value: RESPONSE.CREATE_REPORT,\n      },\n      {\n        type: 'primary',\n        text: 'Discard',\n        value: RESPONSE.SET_STUDY_AND_SERIES,\n      },\n    ];\n    const onSubmit = result => {\n      UIViewportDialogService.hide();\n      resolve(result);\n    };\n\n    UIViewportDialogService.show({\n      viewportId,\n      type: 'warning',\n      message,\n      actions,\n      onSubmit,\n      onOutsideClick: () => {\n        UIViewportDialogService.hide();\n        resolve(RESPONSE.CANCEL);\n      },\n    });\n  });\n}\n\nexport default promptTrackNewSeries;\n","import i18n from 'i18next';\nimport { measurementTrackingMode } from './promptBeginTracking';\n\nconst RESPONSE = {\n  NO_NEVER: -1,\n  CANCEL: 0,\n  CREATE_REPORT: 1,\n  ADD_SERIES: 2,\n  SET_STUDY_AND_SERIES: 3,\n  NO_NOT_FOR_SERIES: 4,\n};\n\nfunction promptTrackNewStudy({ servicesManager, extensionManager }: withAppTypes, ctx, evt) {\n  const { uiViewportDialogService, customizationService } = servicesManager.services;\n  // When the state change happens after a promise, the state machine sends the retult in evt.data;\n  // In case of direct transition to the state, the state machine sends the data in evt;\n  const { viewportId, StudyInstanceUID, SeriesInstanceUID } = evt.data || evt;\n\n  return new Promise(async function (resolve, reject) {\n    const appConfig = extensionManager._appConfig;\n\n    const standardMode = appConfig?.measurementTrackingMode === measurementTrackingMode.STANDARD;\n    const simplifiedMode =\n      appConfig?.measurementTrackingMode === measurementTrackingMode.SIMPLIFIED;\n    let promptResult = standardMode\n      ? await _askTrackMeasurements(uiViewportDialogService, customizationService, viewportId)\n      : RESPONSE.SET_STUDY_AND_SERIES;\n\n    if (promptResult === RESPONSE.SET_STUDY_AND_SERIES) {\n      promptResult =\n        ctx.isDirty && (standardMode || simplifiedMode)\n          ? await _askSaveDiscardOrCancel(uiViewportDialogService, customizationService, viewportId)\n          : RESPONSE.SET_STUDY_AND_SERIES;\n    }\n\n    resolve({\n      userResponse: promptResult,\n      StudyInstanceUID,\n      SeriesInstanceUID,\n      viewportId,\n      isBackupSave: false,\n    });\n  });\n}\n\nfunction _askTrackMeasurements(\n  UIViewportDialogService: AppTypes.UIViewportDialogService,\n  customizationService: AppTypes.CustomizationService,\n  viewportId\n) {\n  return new Promise(function (resolve, reject) {\n    const message = customizationService.getCustomization(\n      'viewportNotification.trackNewStudyMessage'\n    );\n    const actions = [\n      { type: 'cancel', text: i18n.t('MeasurementTable:No'), value: RESPONSE.CANCEL },\n      {\n        type: 'secondary',\n        text: i18n.t('MeasurementTable:No, do not ask again'),\n        value: RESPONSE.NO_NOT_FOR_SERIES,\n      },\n      {\n        type: 'primary',\n        text: i18n.t('MeasurementTable:Yes'),\n        value: RESPONSE.SET_STUDY_AND_SERIES,\n      },\n    ];\n    const onSubmit = result => {\n      UIViewportDialogService.hide();\n      resolve(result);\n    };\n\n    UIViewportDialogService.show({\n      viewportId,\n      type: 'info',\n      message,\n      actions,\n      onSubmit,\n      onOutsideClick: () => {\n        UIViewportDialogService.hide();\n        resolve(RESPONSE.CANCEL);\n      },\n      onKeyPress: event => {\n        if (event.key === 'Enter') {\n          const action = actions.find(action => action.value === RESPONSE.SET_STUDY_AND_SERIES);\n          onSubmit(action.value);\n        }\n      },\n    });\n  });\n}\n\nfunction _askSaveDiscardOrCancel(\n  UIViewportDialogService: AppTypes.UIViewportDialogService,\n  customizationService: AppTypes.CustomizationService,\n  viewportId\n) {\n  return new Promise(function (resolve, reject) {\n    const message = customizationService.getCustomization(\n      'viewportNotification.discardStudyMessage'\n    );\n    const actions = [\n      { type: 'cancel', text: 'Cancel', value: RESPONSE.CANCEL },\n      {\n        type: 'secondary',\n        text: 'No, discard previously tracked series & measurements',\n        value: RESPONSE.SET_STUDY_AND_SERIES,\n      },\n      {\n        type: 'primary',\n        text: 'Yes',\n        value: RESPONSE.CREATE_REPORT,\n      },\n    ];\n    const onSubmit = result => {\n      UIViewportDialogService.hide();\n      resolve(result);\n    };\n\n    UIViewportDialogService.show({\n      viewportId,\n      type: 'warning',\n      message,\n      actions,\n      onSubmit,\n      onOutsideClick: () => {\n        UIViewportDialogService.hide();\n        resolve(RESPONSE.CANCEL);\n      },\n    });\n  });\n}\n\nexport default promptTrackNewStudy;\n","import promptBeginTracking from '../contexts/TrackedMeasurementsContext/promptBeginTracking';\nimport promptHasDirtyAnnotations from '../contexts/TrackedMeasurementsContext/promptHasDirtyAnnotations';\nimport promptHydrateStructuredReport from '../contexts/TrackedMeasurementsContext/promptHydrateStructuredReport';\nimport promptTrackNewSeries from '../contexts/TrackedMeasurementsContext/promptTrackNewSeries';\nimport promptTrackNewStudy from '../contexts/TrackedMeasurementsContext/promptTrackNewStudy';\nimport { promptLabelAnnotation, promptSaveReport } from '@ohif/extension-default';\n\nexport default {\n  'measurement.promptBeginTracking': promptBeginTracking,\n  'measurement.promptHydrateStructuredReport': promptHydrateStructuredReport,\n  'measurement.promptTrackNewSeries': promptTrackNewSeries,\n  'measurement.promptTrackNewStudy': promptTrackNewStudy,\n  'measurement.promptLabelAnnotation': promptLabelAnnotation,\n  'measurement.promptSaveReport': promptSaveReport,\n  'measurement.promptHasDirtyAnnotations': promptHasDirtyAnnotations,\n};\n","import { measurementTrackingMode } from '../contexts/TrackedMeasurementsContext/promptBeginTracking';\n\ntype CheckHasDirtyAndSimplifiedModeProps = {\n  servicesManager: AppTypes.ServicesManager;\n  appConfig: AppTypes.Config;\n  displaySetInstanceUID: string;\n};\n\nconst onDoubleClickHandler = {\n  callbacks: [\n    ({ activeViewportId, servicesManager, isHangingProtocolLayout, appConfig }) =>\n      async displaySetInstanceUID => {\n        const { hangingProtocolService, viewportGridService, uiNotificationService } =\n          servicesManager.services;\n        let updatedViewports = [];\n        const viewportId = activeViewportId;\n        const haveDirtyMeasurementsInSimplifiedMode = checkHasDirtyAndSimplifiedMode({\n          servicesManager,\n          appConfig,\n          displaySetInstanceUID,\n        });\n\n        try {\n          if (!haveDirtyMeasurementsInSimplifiedMode) {\n            updatedViewports = hangingProtocolService.getViewportsRequireUpdate(\n              viewportId,\n              displaySetInstanceUID,\n              isHangingProtocolLayout\n            );\n            viewportGridService.setDisplaySetsForViewports(updatedViewports);\n          }\n        } catch (error) {\n          console.warn(error);\n          uiNotificationService.show({\n            title: 'Thumbnail Double Click',\n            message: 'The selected display sets could not be added to the viewport.',\n            type: 'error',\n            duration: 3000,\n          });\n        }\n      },\n  ],\n};\n\nconst customOnDropHandlerCallback = async props => {\n  const handled = checkHasDirtyAndSimplifiedMode(props);\n  return Promise.resolve({ handled });\n};\n\nconst checkHasDirtyAndSimplifiedMode = (props: CheckHasDirtyAndSimplifiedModeProps) => {\n  const { servicesManager, appConfig, displaySetInstanceUID } = props;\n  const simplifiedMode = appConfig.measurementTrackingMode === measurementTrackingMode.SIMPLIFIED;\n  const { measurementService, displaySetService } = servicesManager.services;\n  const measurements = measurementService.getMeasurements();\n  const haveDirtyMeasurements =\n    measurements.some(m => m.isDirty) ||\n    (measurements.length && measurementService.getIsMeasurementDeletedIndividually());\n  const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n  const hasDirtyAndSimplifiedMode =\n    displaySet.Modality === 'SR' && simplifiedMode && haveDirtyMeasurements;\n  return hasDirtyAndSimplifiedMode;\n};\n\nexport { onDoubleClickHandler, customOnDropHandlerCallback };\n","import { PubSubService } from '@ohif/core';\n\nconst EVENTS = {\n  TRACKED_SERIES_CHANGED: 'event::trackedmeasurements:trackedserieschanged',\n  SERIES_ADDED: 'event::trackedmeasurements:seriesadded',\n  SERIES_REMOVED: 'event::trackedmeasurements:seriesremoved',\n  TRACKING_ENABLED: 'event::trackedmeasurements:trackingenabled',\n  TRACKING_DISABLED: 'event::trackedmeasurements:trackingdisabled',\n};\n\n/**\n * Service class for accessing tracked measurements data.\n * This service provides a robust way to access tracked series information\n * from anywhere in the application, including outside of React components.\n */\nexport class TrackedMeasurementsService extends PubSubService {\n  public static readonly REGISTRATION = {\n    name: 'trackedMeasurementsService',\n    altName: 'TrackedMeasurementsService',\n    create: ({ configuration = {} }) => {\n      return new TrackedMeasurementsService();\n    },\n  };\n\n  private _trackedSeries: string[] = [];\n\n  constructor() {\n    super(EVENTS);\n  }\n\n  /**\n   * Updates the tracked series and notifies subscribers\n   * @param trackedSeries Array of series UIDs being tracked\n   */\n  public updateTrackedSeries(trackedSeries: string[]): void {\n    if (!trackedSeries) {\n      trackedSeries = [];\n    }\n\n    const hasChanged =\n      this._trackedSeries.length !== trackedSeries.length ||\n      this._trackedSeries.some((seriesUID, index) => seriesUID !== trackedSeries[index]);\n\n    if (hasChanged) {\n      const oldSeries = [...this._trackedSeries];\n      this._trackedSeries = [...trackedSeries];\n\n      const wasEmpty = oldSeries.length === 0;\n      const isEmpty = trackedSeries.length === 0;\n\n      if (wasEmpty && !isEmpty) {\n        this._broadcastEvent(EVENTS.TRACKING_ENABLED, {\n          trackedSeries: this.getTrackedSeries(),\n        });\n      } else if (!wasEmpty && isEmpty) {\n        this._broadcastEvent(EVENTS.TRACKING_DISABLED, {\n          trackedSeries: this.getTrackedSeries(),\n        });\n      }\n\n      this._broadcastEvent(EVENTS.TRACKED_SERIES_CHANGED, {\n        trackedSeries: this.getTrackedSeries(),\n      });\n    }\n  }\n\n  /**\n   * Adds a single series to tracking\n   * @param seriesInstanceUID Series instance UID to add to tracking\n   */\n  public addTrackedSeries(seriesInstanceUID: string): void {\n    if (!seriesInstanceUID || this.isSeriesTracked(seriesInstanceUID)) {\n      return;\n    }\n\n    const wasEmpty = this._trackedSeries.length === 0;\n    this._trackedSeries = [...this._trackedSeries, seriesInstanceUID];\n\n    this._broadcastEvent(EVENTS.SERIES_ADDED, {\n      seriesInstanceUID,\n      trackedSeries: this.getTrackedSeries(),\n    });\n\n    if (wasEmpty) {\n      this._broadcastEvent(EVENTS.TRACKING_ENABLED, {\n        trackedSeries: this.getTrackedSeries(),\n      });\n    }\n\n    this._broadcastEvent(EVENTS.TRACKED_SERIES_CHANGED, {\n      trackedSeries: this.getTrackedSeries(),\n    });\n  }\n\n  /**\n   * Removes a single series from tracking\n   * @param seriesInstanceUID Series instance UID to remove from tracking\n   */\n  public removeTrackedSeries(seriesInstanceUID: string): void {\n    if (!seriesInstanceUID || !this.isSeriesTracked(seriesInstanceUID)) {\n      return;\n    }\n\n    this._trackedSeries = this._trackedSeries.filter(uid => uid !== seriesInstanceUID);\n\n    this._broadcastEvent(EVENTS.SERIES_REMOVED, {\n      seriesInstanceUID,\n      trackedSeries: this.getTrackedSeries(),\n    });\n\n    if (this._trackedSeries.length === 0) {\n      this._broadcastEvent(EVENTS.TRACKING_DISABLED, {\n        trackedSeries: this.getTrackedSeries(),\n      });\n    }\n\n    this._broadcastEvent(EVENTS.TRACKED_SERIES_CHANGED, {\n      trackedSeries: this.getTrackedSeries(),\n    });\n  }\n\n  /**\n   * Retrieves the currently tracked series\n   * @returns Array of series UIDs being tracked\n   */\n  public getTrackedSeries(): string[] {\n    return [...this._trackedSeries];\n  }\n\n  /**\n   * Checks if a specific series is being tracked\n   * @param seriesInstanceUID Series instance UID to check\n   * @returns boolean indicating if series is tracked\n   */\n  public isSeriesTracked(seriesInstanceUID: string): boolean {\n    return this._trackedSeries.includes(seriesInstanceUID);\n  }\n\n  /**\n   * Resets the service state\n   */\n  public reset(): void {\n    const wasTracking = this._trackedSeries.length > 0;\n    this._trackedSeries = [];\n\n    if (wasTracking) {\n      this._broadcastEvent(EVENTS.TRACKING_DISABLED, {\n        trackedSeries: [],\n      });\n\n      this._broadcastEvent(EVENTS.TRACKED_SERIES_CHANGED, {\n        trackedSeries: [],\n      });\n    }\n\n    super.reset();\n  }\n\n  /**\n   * Checks if any series are being tracked\n   * @returns boolean indicating if tracking is active\n   */\n  public isTrackingEnabled(): boolean {\n    return this._trackedSeries.length > 0;\n  }\n}\n\nexport default TrackedMeasurementsService;\n","import getContextModule from './getContextModule';\nimport getPanelModule from './getPanelModule';\nimport getViewportModule from './getViewportModule';\nimport { id } from './id.js';\nimport { measurementTrackingMode } from './contexts/TrackedMeasurementsContext/promptBeginTracking';\nimport getCustomizationModule from './getCustomizationModule';\nimport {\n  onDoubleClickHandler,\n  customOnDropHandlerCallback,\n} from './customizations/studyBrowserCustomization';\nimport { TrackedMeasurementsService } from './services';\n// Import types to ensure they're included in the build\nimport './types';\n\nconst measurementTrackingExtension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   */\n  id,\n\n  getContextModule,\n  getPanelModule,\n  getViewportModule,\n\n  /**\n   * Service configuration\n   */\n  preRegistration({ servicesManager }) {\n    servicesManager.registerService(TrackedMeasurementsService.REGISTRATION);\n  },\n\n  onModeEnter({ servicesManager }) {\n    const { customizationService, toolbarService, trackedMeasurementsService } =\n      servicesManager.services;\n\n    toolbarService.registerEventForToolbarUpdate(trackedMeasurementsService, [\n      trackedMeasurementsService.EVENTS.TRACKED_SERIES_CHANGED,\n      trackedMeasurementsService.EVENTS.SERIES_ADDED,\n      trackedMeasurementsService.EVENTS.SERIES_REMOVED,\n      trackedMeasurementsService.EVENTS.TRACKING_ENABLED,\n      trackedMeasurementsService.EVENTS.TRACKING_DISABLED,\n    ]);\n\n    customizationService.setCustomizations({\n      'studyBrowser.thumbnailDoubleClickCallback': {\n        $set: onDoubleClickHandler,\n      },\n      customOnDropHandler: {\n        $set: customOnDropHandlerCallback,\n      },\n    });\n  },\n  getCustomizationModule,\n};\n\nexport default measurementTrackingExtension;\n\nexport { measurementTrackingMode };\n","import measurementTrackingPrompts from './customizations/measurementTrackingPrompts';\n\nexport default function getCustomizationModule() {\n  return [\n    {\n      name: 'default',\n      value: { ...measurementTrackingPrompts },\n    },\n  ];\n}\n"],"names":["RESPONSE","measurementTrackingMode","STANDARD","SIMPLIFIED","NONE","servicesManager","extensionManager","ctx","evt","uiViewportDialogService","customizationService","services","appConfig","_appConfig","viewportId","StudyInstanceUID","SeriesInstanceUID","data","Promise","async","resolve","reject","standardMode","promptResult","message","getCustomization","actions","id","type","text","i18n","t","value","onSubmit","result","hide","show","onOutsideClick","onKeyPress","event","key","action","find","_askTrackMeasurements","userResponse","machineConfiguration","initial","context","activeViewportId","trackedStudy","trackedSeries","ignoredSeries","prevTrackedStudy","prevTrackedSeries","prevIgnoredSeries","ignoredSRSeriesForHydration","isDirty","states","off","labellingOnly","on","TRACK_SERIES","target","idle","entry","cond","SET_TRACKED_SERIES","PROMPT_HYDRATE_SR","RESTORE_PROMPT_HYDRATE_SR","HYDRATE_SR","UPDATE_ACTIVE_VIEWPORT_ID","assign","_","promptBeginTracking","invoke","src","onDone","onError","tracking","UNTRACK_SERIES","UNTRACK_ALL","SAVE_REPORT","SET_DIRTY","CHECK_DIRTY","promptTrackNewSeries","promptTrackNewStudy","promptSaveReport","promptHydrateStructuredReport","hydrateStructuredReport","promptLabelAnnotation","promptHasDirtyAnnotations","strict","defaultOptions","discardPreviouslyTrackedMeasurements","console","log","clearAllMeasurements","jumpToFirstMeasurementInActiveViewport","warn","showStructuredReportDisplaySetInActiveViewport","clearContext","setTrackedStudyAndSeries","slice","setTrackedStudyAndMultipleSeries","studyInstanceUID","seriesInstanceUIDs","SeriesInstanceUIDs","setIsDirtyToClean","setIsDirty","ignoreSeries","ignoreHydrationForSRSeries","srSeriesInstanceUID","addTrackedSeries","removeTrackedSeries","filter","ser","setPreviousState","meta","prevState","state","guards","shouldSetDirty","undefined","includes","wasLabellingOnly","condMeta","wasIdle","wasTracking","wasTrackingAndIsNewStudy","wasTrackingAndIsNewSeries","shouldKillMachine","shouldAddSeries","shouldSetStudyAndSeries","shouldAddIgnoredSeries","shouldPromptSaveReport","shouldIgnoreHydrationForSR","shouldSaveAndContinueWithSameReport","isBackupSave","shouldSaveAndStartNewReport","shouldHydrateStructuredReport","hasRemainingTrackedSeries","length","hasNotIgnoredSRSeriesForHydration","isNewStudy","isNewSeries","commandsManager","displaySetService","displaySetInstanceUID","srDisplaySet","getDisplaySetByUID","hydrationResult","baseHydrateStructuredReport","promptBeginTrackingWrapper","promptHydrateStructuredReportWrapper","promptTrackNewSeriesWrapper","promptTrackNewStudyWrapper","promptLabelAnnotationWrapper","promptSaveReportWrapper","promptHasDirtyAnnotationsWrapper","TrackedMeasurementsContext","React","displayName","useTrackedMeasurements","useContext","SR_SOP_CLASS_HANDLER_ID","COMPREHENSIVE_3D_SR_SOP_CLASS_HANDLER_ID","hasValidSOPClassHandlerId","displaySet","SOPClassHandlerId","TrackedMeasurementsContextProvider","children","useAppConfig","viewportGrid","viewportGridService","useViewportGrid","viewports","measurementService","trackedMeasurementsService","machineOptions","Object","trackedMeasurements","getMeasurements","m","referenceStudyUID","referenceSeriesUID","referencedDisplaySetUID","referencedImages","images","isVolumeIdReferenced","imageId","startsWith","measurementData","imageIndex","findIndex","image","imageIdToUse","keys","substring","setDisplaySetsForViewport","displaySetInstanceUIDs","viewportOptions","initialImageOptions","index","jumpToSameImageInActiveViewport","measurements","trackedMeasurement","runCommand","referencedImageId","createdDisplaySetInstanceUIDs","StructuredReportDisplaySetInstanceUID","measurementIds","ms","map","fm","i","remove","clearMeasurements","setIsMeasurementDeletedIndividually","clearDisplaySetHydratedState","displaysets","getActiveDisplaySets","forEach","displayset","Modality","isHydrated","isLoaded","updatedViewports","hangingProtocolService","getViewportsRequireUpdate","setDisplaySetsForViewports","bind","isLabelOnMeasure","labelConfig","labelOnMeasure","isLabelOnMeasureAndShouldKillMachine","isSimplifiedConfig","simplifiedAndLoadSR","hasDirtyAndSimplified","hasDirtyMeasurements","some","measurement","getIsMeasurementDeletedIndividually","measurementTrackingMachine","useMemo","Machine","sendTrackedMeasurementsEvent","useMachine","useEffect","updateTrackedSeries","size","activeViewport","get","load","isRehydratable","params","disableConfirmationPrompts","triggerPromptHydrateFlow","registerCommand","commandFn","props","Provider","propTypes","PropTypes","BoundTrackedMeasurementsContextProvider","name","provider","UntrackSeriesModal","onConfirm","className","FooterAction","Right","Secondary","onClick","Primary","thumbnailNoImageModalities","PanelStudyBrowserTracking","getImageSrc","getStudiesForPatientByMRN","requestDisplaySetCreationForStudy","dataSource","useSystem","uiModalService","checkDirtyMeasurements","getActiveViewportId","subscriptionOndropFired","subscribe","EVENTS","VIEWPORT_ONDROP_HANDLED","eventData","unsubscribe","getComponentType","ds","unsupported","thumbnailSrc","PanelStudyBrowser","customMapDisplaySets","mapDisplaySetsWithTracking","displaySets","displaySetLoadingState","thumbnailImageSrcMap","thumbnailDisplaySets","thumbnailNoImageDisplaySets","excludeFromThumbnailBrowser","componentType","array","loadingProgress","push","description","SeriesDescription","seriesNumber","SeriesNumber","modality","seriesDate","SeriesDate","Date","toLocaleDateString","numInstances","numImageFrames","countIcon","messages","imageSrc","dragData","isTracked","isHydratedForDerivedDisplaySet","onClickUntrack","title","content","contentProps","uid","onDoubleClickThumbnailHandlerCallBack","getImageIdsForDisplaySet","isRequired","cornerstone","canvas","document","createElement","utilities","loadImageToCanvas","thumbnail","then","toDataURL","catch","getActiveDataSource","_getStudiesForPatientByMRN","utilityModule","getModuleEntry","exports","_getStudyForPatientUtility","_getImageSrcFromImageId","useCallback","getCornerstoneLibraries","getImageSrcFromImageId","ex","Error","_createGetImageSrcFromImageIdFn","_requestDisplaySetCreationForStudy","filterMeasurementsBySeriesUID","filterAny","utils","MeasurementFilters","measurementFilter","onUntrackConfirm","createSR","onDelete","Header","AccordionTrigger","asChild","StudySummaryFromMetadata","_extends","ScrollArea","PanelMeasurement","emptyComponent","EmptyComponent","MeasurementTable","isExpanded","Body","sourceChildren","StudyMeasurements","grouping","AccordionGroup","Trigger","MeasurementsOrAdditionalFindings","activeStudyUID","customHeader","StudyMeasurementsActions","iconName","iconLabel","label","component","PanelMeasurementTableTracking","Component","OHIFCornerstoneViewport","fallback","isReferenceViewable","packageJson","UIViewportDialogService","_askSaveDiscardOrCancel","enhancedSrDisplaySet","promptHydrationDialog","hydrateCallback","_askShouldAddMeasurements","simplifiedMode","onDoubleClickHandler","callbacks","isHangingProtocolLayout","uiNotificationService","haveDirtyMeasurementsInSimplifiedMode","checkHasDirtyAndSimplifiedMode","error","duration","customOnDropHandlerCallback","handled","haveDirtyMeasurements","TRACKED_SERIES_CHANGED","SERIES_ADDED","SERIES_REMOVED","TRACKING_ENABLED","TRACKING_DISABLED","TrackedMeasurementsService","PubSubService","constructor","super","_trackedSeries","this","seriesUID","oldSeries","wasEmpty","isEmpty","_broadcastEvent","getTrackedSeries","seriesInstanceUID","isSeriesTracked","reset","isTrackingEnabled","_TrackedMeasurementsService","REGISTRATION","altName","create","configuration","getContextModule","getPanelModule","getViewportModule","preRegistration","registerService","onModeEnter","toolbarService","registerEventForToolbarUpdate","setCustomizations","$set","customOnDropHandler","getCustomizationModule","measurementTrackingPrompts"],"sourceRoot":""}